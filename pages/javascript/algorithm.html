<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 算法 | 蜗蜗🐇</title>
    <meta name="description" content="从零开始一步一步飙起来">
    <link rel="icon" href="/myIcon.ico">
    
    <link rel="preload" href="/assets/css/styles.c7e086f0.css" as="style"><link rel="preload" href="/assets/js/app.c7e086f0.js" as="script"><link rel="preload" href="/assets/js/12.65cc639e.js" as="script"><link rel="prefetch" href="/assets/css/1.styles.68aee00d.css"><link rel="prefetch" href="/assets/css/2.styles.d1dddd6f.css"><link rel="prefetch" href="/assets/js/1.68aee00d.js"><link rel="prefetch" href="/assets/js/10.999d289c.js"><link rel="prefetch" href="/assets/js/11.82756d16.js"><link rel="prefetch" href="/assets/js/13.28310326.js"><link rel="prefetch" href="/assets/js/14.806859aa.js"><link rel="prefetch" href="/assets/js/15.18a18ef2.js"><link rel="prefetch" href="/assets/js/16.c0969d6b.js"><link rel="prefetch" href="/assets/js/17.21096078.js"><link rel="prefetch" href="/assets/js/18.5b4893c3.js"><link rel="prefetch" href="/assets/js/19.da070b39.js"><link rel="prefetch" href="/assets/js/2.d1dddd6f.js"><link rel="prefetch" href="/assets/js/3.bd510fb8.js"><link rel="prefetch" href="/assets/js/4.32fa4d48.js"><link rel="prefetch" href="/assets/js/5.30c1c9c0.js"><link rel="prefetch" href="/assets/js/6.2abe4e41.js"><link rel="prefetch" href="/assets/js/7.0aac4afd.js"><link rel="prefetch" href="/assets/js/8.bb15a03e.js"><link rel="prefetch" href="/assets/js/9.c0befbf8.js">
    <link rel="stylesheet" href="/assets/css/styles.c7e086f0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      蜗蜗🐇
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/pages/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="/pages/gits/" class="nav-link">git</a></div><div class="nav-item"><a href="/pages/javascript/" class="nav-link router-link-active">js集</a></div><div class="nav-item"><a href="/pages/macConfig/" class="nav-link">mac配置小絮</a></div><div class="nav-item"><a href="/pages/toSumUp/" class="nav-link">小结</a></div><div class="nav-item"><a href="/pages/backstage/" class="nav-link">后端</a></div><a href="https://github.com/hxl888" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/pages/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="/pages/gits/" class="nav-link">git</a></div><div class="nav-item"><a href="/pages/javascript/" class="nav-link router-link-active">js集</a></div><div class="nav-item"><a href="/pages/macConfig/" class="nav-link">mac配置小絮</a></div><div class="nav-item"><a href="/pages/toSumUp/" class="nav-link">小结</a></div><div class="nav-item"><a href="/pages/backstage/" class="nav-link">后端</a></div><a href="https://github.com/hxl888" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><a href="/pages/javascript/" aria-current="page" class="sidebar-link">— js 目录 —</a></li><li><a href="/pages/javascript/es6.html" class="sidebar-link">es6</a></li><li><a href="/pages/javascript/numSort.html" class="sidebar-link">js排序算法</a></li><li><a href="/pages/javascript/algorithm.html" aria-current="page" class="active sidebar-link">js 算法</a></li></ul></div><div class="page"><div class="content"><h1 id="js-算法"><a href="#js-算法" class="header-anchor">#</a> js 算法</h1><p>// 股票买卖1-买卖一次</p><div class="language- extra-class"><pre class="language-text"><code>const maxProFit = (prices) =&gt; {
  const len = prices.length;
  const dp = new Array(len).fill([0, 0]);
  dp[0] = [-prices[0], 0];
  for (let i = 1; i &lt; len; i++) {
    dp[i] = [
      Math.max(dp[i - 1][0], -prices[i]),
      Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]),
    ];
  }
  return dp[len - 1][1];
};
const max = maxProFit([1, 2, 8, 2, 6]);
console.log(&quot;max: &quot;, max);

var maxProFit2 = (prices) =&gt; {
  let lowerPrice = prices[0];
  let profit = 0;
  for (let i = 0; i &lt; prices.length; i++) {
    lowerPrice = Math.min(lowerPrice, prices[i]);
    profit = Math.max(profit, prices[i] - lowerPrice);
  }
  return profit;
};
</code></pre></div><p>// 股票2-可以多次买卖</p><div class="language- extra-class"><pre class="language-text"><code>var maxProFit3 = (prices) =&gt; {
  let len = prices.length;
  if (!prices.length || prices.length &lt; 2) return 0;
  // let dp = new Array(len).fill([0,0])
  let dp = Array.from(Array(len), () =&gt; Array(2).fill(0));
  dp[0][0] = -prices[0];
  dp[0][1] = 0;
  for (let i = 1; i &lt; len; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
  }
  return dp[len - 1][1];
};
const max3 = maxProFit3([1, 2, 8, 2, 6, 3, 9]);
console.log(&quot;max3: &quot;, max3);

var maxProFit3_2 = (prices) =&gt; {
  let len = prices.length,
    have = -prices[0],
    notHave = 0;
  for (let i = 1; i &lt; len; i++) {
    have = Math.max(have, notHave - prices[i]);
    notHave = Math.max(notHave, have + prices[i]);
  }
  return notHave;
};
const max3_2 = maxProFit3_2([1, 2, 8, 2, 6]);
console.log(&quot;max3_2: &quot;, max3_2);
</code></pre></div><p>// 股票3 ---最多买卖两次</p><div class="language- extra-class"><pre class="language-text"><code>var maxProFit4 = (prices) =&gt; {
  let len = prices.length,
    dp = new Array(len).fill().map((x) =&gt; Array(5).fill(0));
  dp[0][0] = 0;
  dp[0][1] = -prices[0];
  dp[0][3] = -prices[0];
  for (let i = 1; i &lt; len; i++) {
    dp[i][0] = dp[i - 1][0];
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
    dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
    dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
  }
  return dp[len - 1][4];
};
const max4 = maxProFit4([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);
console.log(&quot;max4: &quot;, max4);

const maxProfit4_2 = (prices) =&gt; {
  const len = prices.length;
  const dp = new Array(len).fill(0);
  dp[1] = -prices[0];
  dp[3] = -prices[0];
  for (let i = 1; i &lt; len; i++) {
    dp[1] = Math.max(dp[1], dp[0] - prices[i]);
    dp[2] = Math.max(dp[2], dp[1] + prices[i]);
    dp[3] = Math.max(dp[3], dp[2] - prices[i]);
    dp[4] = Math.max(dp[4], dp[3] + prices[i]);
  }
  return dp[4];
};

const max4_2 = maxProfit4_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);
console.log(&quot;max4_2: &quot;, max4_2);
</code></pre></div><p>// 股票--含有冷冻期</p><div class="language- extra-class"><pre class="language-text"><code>const maxProfit5 = (prices) =&gt; {
  const len = prices.length;
  if (len &lt; 2) {
    return 0;
  } else if (len &lt; 3) {
    return Math.max(0, prices[1] - prices[0]);
  }
  const dp = Array.from(Array(len), () =&gt; Array(4).fill(0));
  dp[0][0] = 0 - prices[0];
  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  // 2:今天卖出股票
  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
  for (let i = 1; i &lt; len; i++) {
    dp[i][0] = Math.max(
      dp[i - 1][0],
      Math.max(dp[i - 1][1], dp[i - 1][3]) - prices[i]
    );
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
    dp[i][2] = dp[i - 1][0] + prices[i];
    dp[i][3] = dp[i - 1][2];
  }
  return Math.max(dp[len - 1][1], dp[len - 1][2], dp[len - 1][3]);
};

const max5 = maxProfit5([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);
console.log(&quot;max5: &quot;, max5);
</code></pre></div><p>// 股票--含有冷冻期_2</p><div class="language- extra-class"><pre class="language-text"><code>const maxProfit5_2 = (prices) =&gt; {
  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  // 2:今天卖出股票
  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
  const len = prices.length;
  const dp = new Array(len).fill(0);
  for (let i = 1; i &lt; len; i++) {
    const temp1 = dp[0];
    const temp2 = dp[2];
    dp[0] = Math.max(dp[0], Math.max(dp[1], dp[3]) - prices[i]);
    dp[1] = Math.max(dp[1], dp[3]);
    dp[2] = temp1 + prices[i];
    dp[3] = temp2;
  }
  return Math.max(...dp);
};

const max5_2 = maxProfit5_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);
console.log(&quot;max5_2: &quot;, max5_2);
</code></pre></div><p>/**</p><ul><li>给定一个含有 n 个正整数的数组和一个正整数 target 。</li></ul><p>找出该数组中满足其总和大于等于 target 的长度最小的 连续
子数组
子数组
子数组 是数组中连续的 非空 元素序列。</p><p>[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0
*/
//  长度最小的子数组</p><div class="language- extra-class"><pre class="language-text"><code>var minSubArrayLen = function (target, nums) {
  let left = (right = 0),
    len = nums.length,
    sum = 0,
    res = len + 1;
  while (right &lt; len) {
    sum += nums[right];
    while (sum &gt;= target) {
      res = Math.min(res, right - left + 1);
      sum -= nums[left++];
    }
    right++;
  }
  return res &gt; len ? 0 : res;
};
</code></pre></div><p>/**</p><ul><li><ol start="59"><li>螺旋矩阵 II (https://leetcode.cn/problems/spiral-matrix-ii/description/)</li></ol></li><li>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</li><li></li></ul><p>*/</p><div class="language- extra-class"><pre class="language-text"><code>var generateMatrix = function (n) {
  let starX = (startY = 0),
    offset = 1,
    loop = Math.floor(n / 2),
    mid = Math.floor(n / 2),
    count = 1;
  let res = Array(n)
    .fill(0)
    .map(() =&gt; Array(n).fill(0));

  while (loop--) {
    let row = starX,
      col = startY;
    // 上行从左到右
    for (; col &lt; n - offset; col++) {
      res[row][col] = count++;
    }
    // 右列从上到下
    for (; row &lt; n - offset; row++) {
      res[row][col] = count++;
    }
    // 下行从右到左
    for (; col &gt; startY; col--) {
      res[row][col] = count++;
    }
    // 左列从下到上
    for (; row &gt; starX; row--) {
      res[row][col] = count++;
    }
    starX++;
    startY++;
    offset++;
  }
  if (n % 2 === 1) {
    res[mid][mid] = count;
  }
  return res;
};
</code></pre></div><p>// 链表</p><div class="language- extra-class"><pre class="language-text"><code>class ListNode {
  constructor(value, next) {
    this.val = value;
    this.next = next;
  }
}
</code></pre></div><p>// 删除列表</p><div class="language- extra-class"><pre class="language-text"><code>var removeElements = function (head, val) {
  const dummyHead = new ListNode(0, head);
  let cur = dummyHead;
  while (cur.next) {
    if (cur.next.val === val) {
      cur.next = cur.next.next;
      continue;
    }
    cur = cur.next;
  }
  return dummyHead.next;
};
</code></pre></div><p>// 设计链表</p><div class="language- extra-class"><pre class="language-text"><code>var ListNode = function (val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
};

var MyLinkedList = function () {
  this.size = 0;
  this.head = new ListNode(0);
};

/**
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.getNode = function (index) {
  if (index &lt; 0 || index &gt;= this.size) return -1;
  let cur = this.head;
  while (index-- &gt;= 0) {
    cur = cur.next;
  }
  return cur.val;
};

MyLinkedList.prototype.get = function (index) {
  return this.getNode(index);
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
  this.addAtIndex(0, val);
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
  this.addAtIndex(this.size, val);
};

/**
 * @param {number} index
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
  if (index &gt; this.size) return;
  index = Math.max(0, index);
  this.size++;
  let cur = this.head;
  while (index--) {
    cur = cur.next;
  }
  let toAdd = new ListNode(val);
  toAdd.next = cur.next;
  cur.next = toAdd;
};

/**
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
  if (index &lt; 0 || index &gt;= this.size) return;
  this.size--;
  let cur = this.head;
  while (index--) {
    cur = cur.next;
  }
  cur.next = cur.next.next;
};

</code></pre></div><p>/**</p><ul><li>翻转链表</li><li>@param {*} head</li><li>@returns
*/
//
// 双指针</li></ul><div class="language- extra-class"><pre class="language-text"><code>var reverseList = function (head) {
  if (!head || !head.next) return head;
  let pre = null,
    cur = head,
    temp = null;
  while (cur) {
    temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
</code></pre></div><p>// 翻转链表-递归1</p><div class="language- extra-class"><pre class="language-text"><code>var reverse = function (pre, head) {
  if (!head) return pre;
  let temp = head.next;
  head.next = pre;
  pre = head;
  reverse(pre, temp);
};
var reverseList = function (head) {
  reverse(null, head);
};
</code></pre></div><p>// 24. 两两交换链表中的节点</p><div class="language- extra-class"><pre class="language-text"><code>var swapPairs = function (head) {
  let ret = new ListNode(0, head),
    temp = ret;
  while (temp.next &amp;&amp; temp.next.next) {
    let cur = temp.next.next,
      pre = temp.next;
    pre.next = cur.next;
    cur.next = pre;
    temp.next = cur;
    temp = pre;
  }
  return ret.next;
};
</code></pre></div><p>// 19. 删除链表的倒数第 N 个结点</p><div class="language- extra-class"><pre class="language-text"><code>var removeNthFromEnd = function (head, n) {
  let ret = new ListNode(0, head),
    slow = (fast = ret);
  while (n--) {
    fast = fast.next;
  }
  while (fast.next !== null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return ret.next;
};
</code></pre></div><p>// 142. 环形链表 II (给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。)</p><div class="language- extra-class"><pre class="language-text"><code>var detectCycle = function (head) {
  if (!head || !head.next) return null;
  let slow = (fast = head);
  while (fast &amp;&amp; fast.next &amp;&amp; fast.next.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast === slow) {
      slow = head;
      while (fast !== slow) {
        fast = fast.next;
        slow = slow.next;
      }
      return slow;
    }
  }
  return null;
};
</code></pre></div><p>// 02.07. 链表相交 1</p><div class="language- extra-class"><pre class="language-text"><code>var getIntersectionNode1 = function (headA, headB) {
  if (!headA || !headB) return null;
  let curA = headA,
    curB = headB;
  while (curA !== curB) {
    curA = curA ? curA.next : headB;
    curB = curB ? curB.next : headA;
  }
  return curA;
};
</code></pre></div><p>// 02.07. 链表相交 2</p><div class="language- extra-class"><pre class="language-text"><code>var getIntersectionNode2 = function (headA, headB) {
  if (!headA || !headB) return null;
  const visited = new Set();
  let temp = headA;
  while (temp) {
    visited.add(temp);
    temp = temp.next;
  }
  temp = headB;
  while (temp) {
    if (visited.has(temp)) return temp;
    temp = temp.next;
  }
  return null;
};
</code></pre></div><p>// 242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
// 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><div class="language- extra-class"><pre class="language-text"><code>var isAnagram = function (s, t) {
  if (s.length !== t.length) return false;
  let ret = new Array(26).fill(0),
    base = &quot;a&quot;.charCodeAt();
  for (const i of s) {
    ret[i.charCodeAt() - base]++;
  }
  for (const i of t) {
    if (!ret[i.charCodeAt() - base]) return false;
    ret[i.charCodeAt() - base]--;
  }
  return true;
};
var isAnagram2 = function (s, t) {
  if (s.length !== t.length) return false;
  let ret = new Map();
  for (const i of s) {
    ret.set(i, (ret.get(i) || 0) + 1);
  }
  for (const i of t) {
    if (!ret.get(i)) return false;
    ret.set(i, ret.get(i) - 1);
  }
  return true;
};
</code></pre></div><p>// 349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的 交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。
// https://leetcode.cn/problems/intersection-of-two-arrays/</p><div class="language- extra-class"><pre class="language-text"><code>var intersection = function (nums1, nums2) {
  if (nums1.length &lt; nums2.length) {
    [nums2, nums1] = [nums1, nums2];
  }
  let ret1 = new Set(nums1),
    ret2 = new Set();
  for (let i = 0; i &lt; nums2.length; i++) {
    ret1.has(nums2[i]) &amp;&amp; ret2.add(nums2[i]);
  }
  return Array.from(ret2);
};
</code></pre></div><p>// 202. 快乐数
//「快乐数」 定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
// 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
// 如果这个过程 结果为 1，那么这个数就是快乐数。
// 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><div class="language- extra-class"><pre class="language-text"><code>var isHappy = function (n) {
  let m = new Set();
  let getSum = (num) =&gt; {
    let sum = 0;
    while (num) {
      sum += (num % 10) ** 2;
      num = Math.floor(num / 10);
    }
  };
  // 1
  // while(true) {
  //   if (m.has(n)) return false
  //   if (n === 1) return true
  //   n = getSum(n)
  //   m.add(n)
  // }
  // 2
  while (n !== 1 &amp;&amp; !m.has(n)) {
    m.add(n);
    n = getSum(n);
  }
  return n === 1;
};
isHappy(19);
</code></pre></div><p>// 1. 两数之和</p><div class="language- extra-class"><pre class="language-text"><code>var twoSum = function (nums, target) {
  let has = {};
  for (let i = 0; i &lt; nums.length; i++) {
    if (has[target - nums[i]] !== undefined) {
      return [i, has[target - nums[i]]];
    }
    has[nums[i]] = i;
  }
  return [];
};
</code></pre></div><p>// 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><div class="language- extra-class"><pre class="language-text"><code>var fourSumCount = function (nums1, nums2, nums3, nums4) {
  let map = new Map();
  nums1.forEach((n1) =&gt;
    nums2.forEach((n2) =&gt; map.set(n1 + n2, (map.get(n1 + n2) || 0) + 1))
  );
  let count = 0;
  for (let n3 of nums3) {
    for (let n4 of nums4) {
      if (map.has(-(n3 + n4))) {
        count += map.get(-(n3 + n4));
      }
    }
  }
  return count;
};
</code></pre></div><p>// 383. 赎金信 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><div class="language- extra-class"><pre class="language-text"><code>var canConstruct = function (ransomNote, magazine) {
  let strArr = Array(26).fill(0),
    base = &quot;a&quot;.charCodeAt();
  for (let i of magazine) {
    strArr[i.charCodeAt() - base]++;
  }
  for (let u of ransomNote) {
    let index = u.charCodeAt() - base;
    if (!strArr[index]) return false;
    strArr[index]--;
  }
  return true;
};
</code></pre></div><p>// 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
// 你返回所有和为 0 且不重复的三元组。</p><div class="language- extra-class"><pre class="language-text"><code>var threeSum = function (nums) {
  let res = [],
    len = nums.length;
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; len; i++) {
    let l = i + 1,
      r = len - 1,
      iNum = nums[i];
    if (iNum &gt; 0) return res;
    if (iNum === nums[i - 1]) continue;
    while (l &lt; r) {
      let lNum = nums[l],
        rNum = nums[r],
        threeSum = iNum + lNum + rNum;
      if (threeSum &lt; 0) l++;
      else if (threeSum &gt; 0) r--;
      else {
        res.push([iNum, lNum, rNum]);
        while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) {
          l++;
        }
        while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) {
          r--;
        }
        l++;
        r--;
      }
    }
  }
  return res;
};
</code></pre></div><p>// 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）</p><div class="language- extra-class"><pre class="language-text"><code>var fourSum = function (nums, target) {
  let res = [],
    len = nums.length;
  if (len &lt; 4) return [];
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; len - 3; i++) {
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;

    for (let j = i + 1; j &lt; len - 2; j++) {
      if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue;

      let l = j + 1,
        r = len - 1;
      while (l &lt; r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        if (sum &gt; target) r--;
        else if (sum &lt; target) l++;
        else {
          res.push([nums[i], nums[j], nums[l], nums[r]]);
          // while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) {
          //   l++
          // }
          // while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) {
          //   r--;
          // }
          // l++
          // r--
          while (l &lt; r &amp;&amp; nums[l] === nums[++l]);
          while (l &lt; r &amp;&amp; nums[r] === nums[--r]);
        }
      }
    }
  }
  return res;
};
</code></pre></div><p>// 344. 反转字符串
// 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><div class="language- extra-class"><pre class="language-text"><code>var reverseString = function (s) {
  // let l = -1,r = s.length;
  // while(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]]
  let l = 0,
    r = s.length - 1,
    temp = null;
  while (l &lt; r) {
    temp = s[l];
    s[l] = s[r];
    s[r] = temp;
    l++;
    r--;
  }
};
</code></pre></div><p>// 541. 反转字符串 II
// 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><div class="language- extra-class"><pre class="language-text"><code>var reverseStr = function (s, k) {
  let len = s.length,
    resArr = s.split(&quot;&quot;);
  // for (let i = 0; i &lt; len; i += 2 * k) {
  //   let l = i - 1,
  //     r = i + k &gt; len ? len : i + k;
  //   while (++l &lt; --r) [[resArr[l]], resArr[r]] = [[resArr[r]], resArr[l]];
  // }
  for (let i = 0; i &lt; len; i += 2 * k) {
    let l = i - 1,
      r = i + k &gt; len ? len : i + k,
      temp = null;
    while (++l &lt; --r) {
      temp = resArr[l];
      resArr[l] = resArr[r];
      resArr[r] = temp;
    }
  }
  return resArr.join(&quot;&quot;);
};
</code></pre></div><p>// 替换数字（第八期模拟笔试）
// 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 &quot;a1b2c3&quot;，函数应该将其转换为 &quot;anumberbnumbercnumber&quot;。</p><div class="language- extra-class"><pre class="language-text"><code>let numberToStringFn = function (str) {
  let num0 = &quot;0&quot;.charCodeAt(),
    num9 = &quot;9&quot;.charCodeAt(),
    a = &quot;a&quot;.charCodeAt(),
    z = &quot;z&quot;.charCodeAt(),
    len = str.length,
    n = 0;
  let isNumber = (code) =&gt; {
    code = code.charCodeAt();
    return code &gt;= num0 &amp;&amp; code &lt;= num9;
  };
  let isAz = (code) =&gt; {
    code = code.charCodeAt();
    return code &gt;= a &amp;&amp; code &lt;= z;
  };
  // 计算新数组长度
  for (let i = 0; i &lt; len; i++) {
    if (isNumber(str[i])) {
      n += 6;
    } else if (isAz(str[i])) {
      n += 1;
    } else {
      n += 1;
    }
  }
  let newArr = Array(n).fill(&quot;&quot;),
    index = n - 1;
  for (let i = len - 1; i &gt;= 0; i--) {
    if (isAz(str[i])) {
      // 字符串
      newArr[index] = str[i];
      index--;
    } else if (isNumber(str[i])) {
      // number
      newArr[index] = &quot;r&quot;;
      newArr[index - 1] = &quot;e&quot;;
      newArr[index - 2] = &quot;b&quot;;
      newArr[index - 3] = &quot;m&quot;;
      newArr[index - 4] = &quot;u&quot;;
      newArr[index - 5] = &quot;n&quot;;
      index -= 6;
    }
  }
  console.log(newArr.join(&quot;&quot;));
  console.log(newArr.join(&quot;&quot;).length);
};

numberToStringFn(&quot;12jsd3k2n5k6k9&quot;);
</code></pre></div><p>// 151. 反转字符串中的单词
/**</p><ul><li>给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
*/</li></ul><div class="language- extra-class"><pre class="language-text"><code>var reverseWords = function (s) {
  // function removeExtraSpaces(strArr) {
  //   let slowIndex = 0, fastIndex = 0;
  //   while(fastIndex &lt; strArr.length) {
  //     if (strArr[fastIndex] === ' ' &amp;&amp; (fastIndex === 0 || strArr[fastIndex - 1] === ' ')) {
  //       fastIndex++
  //     } else {
  //       strArr[slowIndex++] = strArr[fastIndex++]
  //     }
  //   }
  //   strArr.length = strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex
  // }
  // function reverse(strArr, start, end) {
  //   let l = start,r = end;
  //   while(l &lt; r) {
  //     [strArr[r], strArr[l]] = [strArr[l], strArr[r]]
  //     l++
  //     r--
  //   }
  // }

  // const strArr = Array.from(s)
  // removeExtraSpaces(strArr)
  // // 翻转
  // reverse(strArr, 0, strArr.length - 1)
  // let start = 0
  // for(let i = 0; i &lt;= strArr.length;i++) {
  //   if (strArr[i] === ' ' || i === strArr.length) {
  //     reverse(strArr, start, i - 1)
  //     start = i + 1
  //   }
  // }
  // return strArr.join('')

  // 2--------
  const strArr = s.trim().split(/\s+/);
  let i = 0,
    j = strArr.length - 1;
  for (; i &lt;= j; i++, j--) {
    // 1----------
    // [strArr[j], strArr[i]] = [strArr[i], strArr[j]];

    // 2----------
    let tmp = sArr[i];
    sArr[i] = sArr[j];
    sArr[j] = tmp;
  }
  return strArr.join(&quot; &quot;);
};
reverseWords(&quot;asdf sd adf sd fe&quot;);

</code></pre></div><p>// 右旋字符串</p><div class="language- extra-class"><pre class="language-text"><code>function reverseStrFn(arr, start, end) {
  let l = start,
    r = end;
  while (l &lt; r) {
    [arr[r], arr[l]] = [arr[l], arr[r]];
    l++;
    r--;
  }
  return arr;
}

function reVerArr(arr, n) {
  reverseStrFn(arr, 0, arr.length - 1);
  reverseStrFn(arr, 0, n - 1);
  reverseStrFn(arr, n, arr.length - 1);
  console.log(&quot;arr: &quot;, arr.join(&quot;&quot;));
  return arr.join(&quot;&quot;);
}
let arr = Array.from(&quot;asbejkl&quot;);
reVerArr(arr, 3);
</code></pre></div><p>// 28. 找出字符串中第一个匹配项的下标
/**</p><ul><li>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</li><li>@param {*} haystack</li><li>@param {*} needle
*/</li></ul><div class="language- extra-class"><pre class="language-text"><code>var strStr = function (haystack, needle) {
 if (!needle.length) return 0;
 var getNext = (needle) =&gt; {
   let j = 0,
     next = [];
   next[0] = 0;
   for (let i = 1; i &lt; needle.length; i++) {
     while (j &gt; 0 &amp;&amp; needle[i] !== needle[j]) {
       console.log(&quot;j: &quot;, j);
       j = next[j - 1];
     }
     if (needle[i] === needle[j]) {
       j++;
     }
     next[i] = j;
   }
   return next;
 };
 let next = getNext(needle);
 let j = 0;
 for (let i = 0; i &lt; haystack.length; i++) {
   while (j &gt; 0 &amp;&amp; haystack[i] !== needle[j]) {
     j = next[j - 1];
   }
   if (haystack[i] === needle[j]) {
     j++;
   }
   if (j === needle.length) {
     return i + 1 - needle.length;
   }
 }
 return -1;
};

const f = strStr(&quot;6sadbutsad&quot;, &quot;sad&quot;);
console.log(&quot;f: &quot;, f);
</code></pre></div><p>// 459.重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成</p><div class="language- extra-class"><pre class="language-text"><code>var repeatedSubstringPattern = function (s) {
  let len = s.length;
  if (!len) return false;
  let getNext = (s) =&gt; {
    let j = 0,
      next = [0];
    for (let i = 1; i &lt; s.length; i++) {
      while (j &gt; 0 &amp;&amp; s[i] !== s[j]) {
        j = next[j - 1];
      }
      if (s[i] === s[j]) {
        j++;
      }
      next.push(j);
    }
    return next;
  };
  let next = getNext(s),
    len2 = next.length;
  return next[len2 - 1] !== 0 &amp;&amp; len % (len - next[len2 - 1]) === 0;
};
</code></pre></div><p>// 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。</p><div class="language- extra-class"><pre class="language-text"><code>var removeElement = function (nums, val) {
  // let k = 0
  // for(let i = 0; i &lt; nums.length; i++) {
  //   if (nums[i] !== val) {
  //     nums[k++] = nums[i]
  //   }
  // }
  // // nums.length = k
  // return k
  let l = 0,
    r = nums.length;
  while (l &lt; r) {
    if (nums[l] === val) {
      nums[l] = nums[--r];
    } else {
      l++;
    }
  }
  nums.length = l;
  console.log(&quot;nums: &quot;, nums);
  return l;
};
removeElement([1, 2, 3, 3, 5, 5], 5);
</code></pre></div><p>// 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><div class="language- extra-class"><pre class="language-text"><code>var MyQueueFn = () =&gt; {
  var MyQueue = function () {
    this.stackIn = [];
    this.stackOut = [];
  };

  /**
   * @param {number} x
   * @return {void}
   */
  MyQueue.prototype.push = function (x) {
    this.stackIn.push(x);
  };

  /**
   * @return {number}
   */
  MyQueue.prototype.pop = function () {
    const size = this.stackOut.length;
    if (size) {
      return this.stackOut.pop();
    }
    while (this.stackIn.length) {
      this.stackOut.push(this.stackIn.pop());
    }
    return this.stackOut.pop();
  };

  /**
   * @return {number}
   */
  MyQueue.prototype.peek = function () {
    const x = this.pop();
    this.stackOut.push(x);
    return x;
  };

  /**
   * @return {boolean}
   */
  MyQueue.prototype.empty = function () {
    return !this.stackIn.length &amp;&amp; !this.stackOut.length;
  };
};
</code></pre></div><p>// 225. 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><div class="language- extra-class"><pre class="language-text"><code>var MyStackFn = () =&gt; {
  var MyStack = function () {
    this.queue1 = [];
    this.queue2 = [];
  };
  /**
   * @param {number} x
   * @return {void}
   */
  MyStack.prototype.push = function (x) {
    this.queue1.push(x);
  };

  /**
   * @return {number}
   */
  MyStack.prototype.pop = function () {
    if (!this.queue1.length) {
      [this.queue2, this.queue1] = [this.queue1, this.queue2];
    }
    while (this.queue1.length &gt; 1) {
      this.queue2.push(this.queue1.shift());
    }
    return this.queue1.shift();
  };

  /**
   * @return {number}
   */
  MyStack.prototype.top = function () {
    var x = this.pop();
    this.queue1.push(x);
    return x;
  };

  /**
   * @return {boolean}
   */
  MyStack.prototype.empty = function () {
    return !this.queue1.length &amp;&amp; !this.queue2.length;
  };
};

// 用一个队列实现-------
class MyStack {
  constructor() {
    this.queue = [];
  }

  push(x) {
    this.queue.push(x);
  }

  pop() {
    // 将队列前面的元素（除了最后一个）全部移到队列末尾
    let size = this.queue.length;
    while (size-- &gt; 1) {
      this.queue.push(this.queue.shift());
    }
    // 移除并返回最后一个元素
    return this.queue.shift();
  }
  top() {
    // 将队列前面的元素（除了最后一个）全部移到队列末尾
    const x = this.pop();
    this.queue.push(x);
  }
  empty() {
    return this.queue.length === 0;
  }
}

// 示例用法：
const stack = new MyStack();
stack.push(1);
stack.push(2);
console.log(stack.top()); // 输出 2
console.log(stack.pop()); // 输出 2
console.log(stack.empty()); // 输出 false
</code></pre></div><p>/**</p><ul><li>有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
*/
// 20. 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效</li></ul><div class="language- extra-class"><pre class="language-text"><code>var isValid = function (s) {
  // let list = [];
  // for(let i of s) {
  //   switch (i) {
  //     case '(':
  //       list.push(')')
  //       break;
  //     case '[':
  //       list.push(']')
  //       break;
  //     case '{':
  //       list.push('}')
  //       break;
  //     default:
  //       if (i !== list.pop()) return false
  //       break;
  //   }
  // }
  // return !list.length
  let list = [],
    map = {
      &quot;(&quot;: &quot;)&quot;,
      &quot;[&quot;: &quot;]&quot;,
      &quot;{&quot;: &quot;}&quot;,
    };
  for (let i of s) {
    if (map[i]) {
      list.push(i);
      continue;
    }
    if (map[list.pop()] !== i) return false;
  }
  return !list.length;
};
isValid(&quot;((&quot;);
</code></pre></div><p>// 1047. 删除字符串中的所有相邻重复项</p><div class="language- extra-class"><pre class="language-text"><code>var removeDuplicates = function (s) {
  // var list = []
  // for(let i of s) {
  //   let lastVal = list.length ? list[list.length - 1] : null
  //   if (i === lastVal) {
  //     list.pop()
  //   } else {
  //     list.push(i)
  //   }
  // }
  // return list.join('')
  let list = [...s],
    top = -1;
  for (let i of s) {
    if (top === -1 || list[top] !== i) {
      list[++top] = i;
    } else {
      top--;
    }
  }
  list.length = top + 1;
  console.log(&quot;list.join&quot;, list.join(&quot;&quot;));
  return list.join(&quot;&quot;);
};
removeDuplicates(&quot;dbccab&quot;);
</code></pre></div><p>// 150. 逆波兰表达式求值 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p><div class="language- extra-class"><pre class="language-text"><code>var evalRPN = function (tokens) {
  let stack = [];
  for (const token of tokens) {
    if (isNaN(Number(token))) {
      // 重点 isNaN()
      const n2 = stack.pop(); // 出栈两个数字
      const n1 = stack.pop();
      switch (token) {
        case &quot;+&quot;:
          stack.push(n1 + n2);
          break;
        case &quot;-&quot;:
          stack.push(n1 - n2);
          break;
        case &quot;*&quot;:
          stack.push(n1 * n2);
          break;
        case &quot;/&quot;:
          const st = (n1 / n2) | 0; // 重点 | 0
          stack.push(st);
          break;
      }
    } else {
      stack.push(Number(token));
    }
  }
  console.log(&quot;stack[0]: &quot;, stack[0]);
  return stack[0];
};

evalRPN([&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]);
</code></pre></div><p>// 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。</p><p>/**</p><ul><li>@param {number[]} nums</li><li>@param {number} k</li><li>@return {number[]}
*/</li></ul><div class="language- extra-class"><pre class="language-text"><code>var maxSlidingWindow = function (nums, k) {
 class MonoQueue {
   queue;
   constructor() {
     this.queue = [];
   }
   enqueue(value) {
     let back = this.queue[this.queue.length - 1];
     while (back !== undefined &amp;&amp; back &lt; value) {
       this.queue.pop();
       back = this.queue[this.queue.length - 1];
     }
     this.queue.push(value);
   }
   dequeue(value) {
     const front = this.front();
     if (front === value) {
       this.queue.shift();
     }
   }
   front() {
     return this.queue[0];
   }
 }
 const helpQueue = new MonoQueue();
 let i = 0,
   j = 0,
   resArr = [];
 // 先将前k个参数循环一遍
 while (j &lt; k) {
   helpQueue.enqueue(nums[j++]);
 }
 resArr.push(helpQueue.front());
 // 再让i从0开始 如果有一样的走过的参数从列表里面删除掉
 while (j &lt; nums.length) {
   helpQueue.enqueue(nums[j++]);
   helpQueue.dequeue(nums[i++]);
   resArr.push(helpQueue.front());
 }
 return resArr;
};
maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);
</code></pre></div><p>/**
*</p><ul><li>在 JavaScript 中，小顶堆通常使用数组来实现。数组表示小顶堆时，元素按层级顺序存储，</li><li>即父节点的索引为 i，其左子节点的索引为 2*i + 1，</li><li>右子节点的索引为 2*i + 2。这种存储方式使得堆的操作非常高效。</li><li></li><li>数组表示的具体规则
根节点：根节点在数组中的索引为 0。
左子节点：对于索引为 i 的节点，左子节点的索引为 2<em>i + 1。
右子节点：对于索引为 i 的节点，右子节点的索引为 2</em>i + 2。
父节点：对于索引为 i 的节点，父节点的索引为 Math.floor((i - 1) / 2)。</li><li></li></ul><p>*/</p><p>// js实现小顶堆</p><div class="language- extra-class"><pre class="language-text"><code>class MinHeap {
  constructor(compareFn) {
    this.head = [];
    this.compareFn = compareFn;
  }
  getParentIndex(index) {
    return Math.floor((index - 1) / 2);
  }
  getLeftChildIndex(index) {
    return index * 2 + 1;
  }
  getRightChildIndex(index) {
    return index * 2 + 2;
  }
  swap(index1, index2) {
    [this.head[index2], this.head[index1]] = [
      this.head[index1],
      this.head[index2],
    ];
  }
  compare(index1, index2) {
    if (this.head[index1] === undefined) return 1;
    if (this.head[index2] === undefined) return -1;
    return this.compareFn(this.head[index1], this.head[index2]);
  }
  insert(val) {
    this.head.push(val);
    this.headPiFyUp();
  }
  // 向上堆积
  headPiFyUp() {
    let index = this.head.length - 1;
    while (index &gt; 0) {
      let parentIndex = this.getParentIndex(index);
      //  this.head[index] &lt; this.head[parentIndex]
      if (this.compare(index, parentIndex) &lt; 0) {
        this.swap(index, parentIndex);
        index = parentIndex;
      } else {
        break;
      }
    }
  }
  remove() {
    let len = this.head.length;
    if (!len) return null;
    if (len === 1) return this.head.pop();
    const root = this.head[0];
    this.head[0] = this.head.pop();
    this.headPiFyDown(0);
    return root;
  }
  // 向下堆积
  headPiFyDown(index) {
    let smallest = index;
    const leftChildrenIndex = this.getLeftChildIndex(index);
    const rightChildrenIndex = this.getRightChildIndex(index);
    // if (leftChildrenIndex &lt; this.head.length &amp;&amp; this.head[leftChildrenIndex] &lt; this.head[smallest]) {
    if (
      leftChildrenIndex &lt; this.head.length &amp;&amp;
      this.compare(leftChildrenIndex, smallest) &lt; 0
    ) {
      smallest = leftChildrenIndex;
    }
    // if (rightChildrenIndex &lt; this.head.length &amp;&amp; this.head[rightChildrenIndex] &lt; this.head[smallest]) {
    if (
      rightChildrenIndex &lt; this.head.length &amp;&amp;
      this.compare(rightChildrenIndex, smallest) &lt; 0
    ) {
      smallest = rightChildrenIndex;
    }
    if (smallest !== index) {
      // 说明进行了转换
      this.swap(index, smallest);
      this.headPiFyDown(smallest);
    }
  }
  getMin() {
    return this.head[0];
  }
  size() {
    return this.head.length;
  }
  isEmpty() {
    return !this.head.length;
  }
  buildHeap(arr) {
    this.head = arr;
    for (let i = Math.floor(this.head.length / 2) - 1; i &gt;= 0; i--) {
      this.headPiFyDown(i);
    }
  }
  printHeap() {
    console.log(this.head);
  }
}

// const testMinHeap = () =&gt; {
//   const minHeap = new MinHeap((a, b) =&gt; a - b)
//   minHeap.insert(10)
//   minHeap.insert(1)
//   minHeap.insert(2)
//   minHeap.insert(3)
//   minHeap.insert(4)
//   minHeap.printHeap()

//   const minVal1 = minHeap.getMin()
//   console.log('minVal1: ', minVal1);

//   minHeap.remove()
//   minHeap.printHeap()

//   const minVal2 = minHeap.getMin()
//   console.log('minVal2: ', minVal2);

//   minHeap.insert(5)
//   minHeap.printHeap()

//   const minVal3 = minHeap.getMin()
//   console.log('minVal3: ', minVal3);
// }
// testMinHeap()
</code></pre></div><p>// 347. 前 K 个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><div class="language- extra-class"><pre class="language-text"><code>var topKFrequent = function (nums, k) {
  const map = new Map();
  for (const i of nums) {
    map.set(i, (map.get(i) || 0) + 1);
  }

  const heap = new MinHeap((a, b) =&gt; a[1] - b[1]);

  for (const i of map.entries()) {
    heap.insert(i);
    if (heap.size() &gt; k) {
      heap.remove();
    }
  }
  const res = [];
  heap.printHeap();
  for (let i = heap.size() - 1; i &gt;= 0; i--) {
    res.push(heap.remove()[0]);
  }
  console.log(&quot;res: &quot;, res);
  return res;
};

topKFrequent([1, 1, 1, 2, 2, 3], 2);

const topKFrequent2 = (nums, k) =&gt; {
  const map = new Map();
  for (const i of nums) {
    map.set(i, (map.get(i) || 0) + 1);
  }
  //返回一个按出现次数降序的二维数组
  let sortArray = Array.from(map).sort((a, b) =&gt; b[1] - a[1]),
    res = [];
  for (let i = 0; i &lt; k; i++) {
    res.push(sortArray[i][0]);
  }
  console.log(&quot;res: &quot;, res);
  return res;
};
topKFrequent2([1, 1, 1, 2, 2, 3], 2);

</code></pre></div><p>// 二叉树节点类</p><div class="language- extra-class"><pre class="language-text"><code>class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
class BinaryTree {
  constructor() {
    this.root = null;
  }
  insert(value) {
    const newNode = new TreeNode(value);
    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }
  insertNode(node, newNode) {
    if (newNode.value &lt; node.value) {
      // 新节点放到left
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      // 新节点放到right
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }
  search(value) {
    return this.searchNode(this.root, value);
  }
  searchNode(root, value) {
    if (root === null) return false;
    if (value &lt; root.value) {
      this.searchNode(root.left, value);
    } else if (value &gt; root.value) {
      this.searchNode(root.right, value);
    } else {
      return true;
    }
  }
  /**
   * 
   * 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式
    前序遍历：中左右
    中序遍历：左中右
    后序遍历：左右中
   */
  // 前序遍历
  preOrder(node = this.root) {
    if (node !== null) {
      console.log(node.value);
      this.preOrder(node.left);
      this.preOrder(node.right);
    }
  }
  // 中序遍历
  inOrder(node = this.root) {
    if (node !== null) {
      this.preOrder(node.left);
      console.log(node.value);
      this.preOrder(node.right);
    }
  }
  // 后序遍历
  postOrder(node = this.root) {
    if (node !== null) {
      this.preOrder(node.left);
      this.preOrder(node.right);
      console.log(node.value);
    }
  }
}

const treeTestFn = () =&gt; {
  const tree = new BinaryTree();
  tree.insert(7);
  tree.insert(4);
  tree.insert(9);
  tree.insert(1);
  tree.insert(6);
  tree.insert(8);
  tree.insert(10);

  console.log(&quot;中序遍历&quot;);
  tree.inOrder();

  console.log(&quot;前序遍历&quot;);
  tree.preOrderOrder();

  console.log(&quot;后序遍历&quot;);
  tree.postOrder();

  console.log(&quot;查找节点&quot;);
  console.log(tree.search(6));
  console.log(tree.search(15));
};
treeTestFn();

const binaryTreeTraversal2 = () =&gt; {
  // 迭代法遍历
  // ---前序遍历---: (中左右) 栈进入顺序 右 -&gt; 左; 出栈  中 -&gt; 左 -&gt; 右
  const preOrderTraversal = (root) =&gt; {
    let res = [];
    if (!root) return res;
    let stack = [root],
      cur = null;
    while (stack.length) {
      cur = stack.pop();
      res.push(cur.val);
      cur.right &amp;&amp; stack.push(cur.right);
      cur.left &amp;&amp; stack.push(cur.left);
    }
    return res;
  };
  // ---前序遍历--- 中左右  压入栈右-&gt;左-&gt;中; 出栈 中-&gt;左-&gt;右
  // const preOrderTraversal = (root) =&gt; {
  //   let res = [],
  //     stack = [root];
  //   while (stack.length) {
  //     const node = stack.pop();
  //     if (!node) {
  //       res.push(stack.pop().val);
  //       continue;
  //     }
  //     node.right &amp;&amp; stack.push(node.right); // 右
  //     node.left &amp;&amp; stack.push(node.left); // 左
  //     stack.push(node); // 中
  //     stack.push(null);
  //   }
  //   return res;
  // };

  // ---中序遍历---: (左中右) 入栈 左 -&gt; 右;  出栈 左 -&gt; 中 -&gt; 右
  const inOrderTraversal = (root) =&gt; {
    if (!root) return [];
    let res = [],
      stack = [],
      cur = root;
    do {
      if (cur) {
        stack.push(cur);
        cur = cur.left;
      } else {
        cur = stack.pop();
        res.push(cur.val);
        cur = cur.right;
      }
    } while (stack.length || cur);
    return res;
  };

  // ---后序遍历---: (左右中) 栈进入顺序 左 -&gt; 右;  出栈  中 -&gt; 右 -&gt; 左 结果翻转
  const postOrderTraversal = (root) =&gt; {
    let res = [];
    if (!root) return res;
    let stack = [root],
      cur = null;
    while (stack.length) {
      cur = stack.pop();
      res.push(cur.val);
      cur.left &amp;&amp; stack.push(cur.left);
      cur.right &amp;&amp; stack.push(cur.right);
    }
    return res.reverse();
  };
  // ---后续遍历--- 左右中
  // const postOrderTraversal_2 = (root) =&gt; {
  //   let res = [];
  //   if (!root) return res;
  //   let stack = [root],
  //     visited = new Set();

  //   while (stack.length) {
  //     const node = stack[stack.length - 1];
  //     if (node.left &amp;&amp; !visited.has(node.left)) {
  //       stack.push(node.left);
  //     } else if (node.right &amp;&amp; !visited.has(node.right)) {
  //       stack.push(node.right);
  //     } else {
  //       res.push(node.val);
  //       visited.add(node);
  //       stack.pop();
  //     }
  //   }
  //   return res;
  // };
};

// 示例二叉树结构
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.left = new TreeNode(6);
root.right.right = new TreeNode(7);

</code></pre></div><p>// 测试前序遍历方法</p><p>// 102.二叉树的层序遍历次  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</p><div class="language- extra-class"><pre class="language-text"><code>const levelOrder = (root) =&gt; {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let curLevel = [],
      len = queue.length;
    for (let i = 0; i &lt; len; i++) {
      const node = queue.shift();
      curLevel.push(node.val);
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
    // res.push(curLevel);
    res.unshift(curLevel);
  }
  return res;
};
// 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
const levelOrderBottom = (root) =&gt; {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let curLevel = [],
      len = queue.length;
    while (len--) {
      const node = queue.shift();
      curLevel.push(node.val);
      // 把下一层级的左右节点存入queue队列
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
    res.unshift(curLevel);
  }
  return res;
};
</code></pre></div><p>// 199.二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</p><div class="language- extra-class"><pre class="language-text"><code>class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.left = new TreeNode(6);
root.right.right = new TreeNode(7);

const rightSideView = (root) =&gt; {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let len = queue.length;
    while (len--) {
      const node = queue.shift();
      if (!len) {
        res.push(node.val);
      }
      // 把下一层级的左右节点存入queue队列
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
  }
  return res;
};
console.log(&quot;rightSideView(root): &quot;, rightSideView(root));
</code></pre></div><p>// 637.二叉树的层平均值  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><div class="language- extra-class"><pre class="language-text"><code>const averageOfLevels = (root) =&gt; {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let sum = 0,
      curLen = queue.length,
      len = curLen;
    while (len--) {
      const node = queue.shift();
      sum += node.val;
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
    res.push(sum / curLen);
  }
  return res;
};

</code></pre></div><p>/**</p><ul><li><ol><li>广度优先搜索（BFS）需要先进先出（FIFO）的队列行为，以确保节点按层次顺序被处理。这就是为什么 shift() 被用于 BFS 的原因</li></ol></li><li><ol start="2"><li>如果使用 pop()，队列将变成后进先出（LIFO）的行为，这是深度优先搜索（DFS）的特性，而不是广度优先搜索。
*/</li></ol></li></ul><p>// 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><div class="language- extra-class"><pre class="language-text"><code>const levelOrderN = function (root) {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let len = queue.length,
      curLevel = [];
    while (len--) {
      const node = queue.shift();
      curLevel.push(node.val);
      for (let item of node.children) {
        item &amp;&amp; queue.push(item);
      }
    }
    res.push(curLevel);
  }
  return res;
};
</code></pre></div><p>// 515. 在每个树行中找最大值 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p><div class="language- extra-class"><pre class="language-text"><code>const largestValues = function (root) {
  if (!root) return [];
  let res = [],
    queue = [root];
  while (queue.length) {
    let len = queue.length,
      max = -Infinity;
    while (len--) {
      const node = queue.shift();
      max = Math.max(max, node.val);
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
    res.push(max);
  }
  return res;
};
</code></pre></div><p>// 116.填充每个节点的下一个右侧节点指针
/**</p><ul><li>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
int val;
Node *left;
Node *right;
Node *next;
}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。
*/</li></ul><div class="language- extra-class"><pre class="language-text"><code>const connect = function (root) {
 if (!root) return root;
 let queue = [root];
 while (queue.length) {
   let len = queue.length;
   while (len--) {
     const node = queue.shift();
     if (len &gt; 0) {
       node.next = queue[0];
     }
     node.left &amp;&amp; queue.push(node.left);
     node.right &amp;&amp; queue.push(node.right);
   }
 }
 return root;
};
</code></pre></div><p>// 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><div class="language- extra-class"><pre class="language-text"><code>const maxDepth = function (root) {
  let max = 0
  if (!root) return max;
  let queue = [root];
  while (queue.length) {
    let len = queue.length;
    max++
    while (len--) {
      const node = queue.shift();
      node.left &amp;&amp; queue.push(node.left);
      node.right &amp;&amp; queue.push(node.right);
    }
  }
  return max;
}
</code></pre></div><p>// 111.二叉树的最小深度</p><div class="language- extra-class"><pre class="language-text"><code>const minDepth = function(root) {
  let min = 0,queue = [root]
  if (!root) return min
  while(queue.length) {
    let len = queue.length
    min++
    while(len--) {
      const node = queue.shift()
      if (!node.left &amp;&amp; !node.right) return min
      node.left &amp;&amp; queue.push(node.left)
      node.right &amp;&amp; queue.push(node.right)
    }
  }
  return min
}
</code></pre></div><p>// 翻转二叉树
// 递归</p><div class="language- extra-class"><pre class="language-text"><code>var invertTree = function(root) {
  if(root == null) return root
  const rightNode = root.right
  root.right = invertTree(root.left)
  root.left = invertTree(rightNode)
  return root
}

// 层序遍历
var invertTree2 = function(root) {
  const invertNode = (root, left, right) =&gt; {
    const temp = left
    root.left = right
    root.right = temp
  }
  if (root == null) return root
  let queue = [root]
  while(queue.length) {
    let len = queue.length
    if (len--) {
      const node = queue.shift()
      invertNode(node, node.left, node.right)
      node.left &amp;&amp; queue.push(node.left)
      node.right &amp;&amp; queue.push(node.right)
    }
  }
  return root
}
// 迭代遍历 (前序遍历中左右); 入栈顺序为：右左 (栈是后进先出原则)
var invertTree3 = function(root) {
  if (root == null) return root
  let queue = [root]
  while (queue.length) {
    let curNode = queue.pop()
    const temp = curNode.left
    curNode.left = curNode.right
    curNode.right = temp

    // 将右子节点入栈
    if (curNode.right) queue.push(curNode.right)

    // 将右子节点入栈
    if (curNode.left) queue.push(curNode.left)
  }
  return root
}
</code></pre></div></div><div class="page-edit"><!----><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/pages/javascript/numSort.html" class="prev">
          js排序算法
        </a></span><!----></p></div></div></div></div>
    <script src="/assets/js/app.c7e086f0.js" defer></script><script src="/assets/js/12.65cc639e.js" defer></script>
  </body>
</html>
