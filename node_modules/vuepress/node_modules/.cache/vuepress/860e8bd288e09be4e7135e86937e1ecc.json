{"remainingRequest":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js??ref--3-0!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/babel-loader/lib/index.js??ref--3-1!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/javascript/algorithm.md?vue&type=template&id=52f775a2","dependencies":[{"path":"/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/javascript/algorithm.md","mtime":1723100283626},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/babel-loader/lib/index.js","mtime":1723084153686},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1723084153489}],"contextDependencies":[],"result":["var render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _vm._m(0);\n};\n\nvar staticRenderFns = [function () {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"div\", {\n    staticClass: \"content\"\n  }, [_c(\"h1\", {\n    attrs: {\n      id: \"js-算法\"\n    }\n  }, [_c(\"a\", {\n    staticClass: \"header-anchor\",\n    attrs: {\n      href: \"#js-算法\"\n    }\n  }, [_vm._v(\"#\")]), _vm._v(\" js 算法\")]), _c(\"p\", [_vm._v(\"// 股票买卖1-买卖一次\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('const maxProFit = (prices) => {\\n  const len = prices.length;\\n  const dp = new Array(len).fill([0, 0]);\\n  dp[0] = [-prices[0], 0];\\n  for (let i = 1; i < len; i++) {\\n    dp[i] = [\\n      Math.max(dp[i - 1][0], -prices[i]),\\n      Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]),\\n    ];\\n  }\\n  return dp[len - 1][1];\\n};\\nconst max = maxProFit([1, 2, 8, 2, 6]);\\nconsole.log(\"max: \", max);\\n\\nvar maxProFit2 = (prices) => {\\n  let lowerPrice = prices[0];\\n  let profit = 0;\\n  for (let i = 0; i < prices.length; i++) {\\n    lowerPrice = Math.min(lowerPrice, prices[i]);\\n    profit = Math.max(profit, prices[i] - lowerPrice);\\n  }\\n  return profit;\\n};\\n')])])]), _c(\"p\", [_vm._v(\"// 股票2-可以多次买卖\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var maxProFit3 = (prices) => {\\n  let len = prices.length;\\n  if (!prices.length || prices.length < 2) return 0;\\n  // let dp = new Array(len).fill([0,0])\\n  let dp = Array.from(Array(len), () => Array(2).fill(0));\\n  dp[0][0] = -prices[0];\\n  dp[0][1] = 0;\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\\n  }\\n  return dp[len - 1][1];\\n};\\nconst max3 = maxProFit3([1, 2, 8, 2, 6, 3, 9]);\\nconsole.log(\"max3: \", max3);\\n\\nvar maxProFit3_2 = (prices) => {\\n  let len = prices.length,\\n    have = -prices[0],\\n    notHave = 0;\\n  for (let i = 1; i < len; i++) {\\n    have = Math.max(have, notHave - prices[i]);\\n    notHave = Math.max(notHave, have + prices[i]);\\n  }\\n  return notHave;\\n};\\nconst max3_2 = maxProFit3_2([1, 2, 8, 2, 6]);\\nconsole.log(\"max3_2: \", max3_2);\\n')])])]), _c(\"p\", [_vm._v(\"// 股票3 ---最多买卖两次\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var maxProFit4 = (prices) => {\\n  let len = prices.length,\\n    dp = new Array(len).fill().map((x) => Array(5).fill(0));\\n  dp[0][0] = 0;\\n  dp[0][1] = -prices[0];\\n  dp[0][3] = -prices[0];\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = dp[i - 1][0];\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\\n    dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\\n    dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\\n  }\\n  return dp[len - 1][4];\\n};\\nconst max4 = maxProFit4([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\\nconsole.log(\"max4: \", max4);\\n\\nconst maxProfit4_2 = (prices) => {\\n  const len = prices.length;\\n  const dp = new Array(len).fill(0);\\n  dp[1] = -prices[0];\\n  dp[3] = -prices[0];\\n  for (let i = 1; i < len; i++) {\\n    dp[1] = Math.max(dp[1], dp[0] - prices[i]);\\n    dp[2] = Math.max(dp[2], dp[1] + prices[i]);\\n    dp[3] = Math.max(dp[3], dp[2] - prices[i]);\\n    dp[4] = Math.max(dp[4], dp[3] + prices[i]);\\n  }\\n  return dp[4];\\n};\\n\\nconst max4_2 = maxProfit4_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\\nconsole.log(\"max4_2: \", max4_2);\\n')])])]), _c(\"p\", [_vm._v(\"// 股票--含有冷冻期\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('const maxProfit5 = (prices) => {\\n  const len = prices.length;\\n  if (len < 2) {\\n    return 0;\\n  } else if (len < 3) {\\n    return Math.max(0, prices[1] - prices[0]);\\n  }\\n  const dp = Array.from(Array(len), () => Array(4).fill(0));\\n  dp[0][0] = 0 - prices[0];\\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\\n  // 2:今天卖出股票\\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = Math.max(\\n      dp[i - 1][0],\\n      Math.max(dp[i - 1][1], dp[i - 1][3]) - prices[i]\\n    );\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);\\n    dp[i][2] = dp[i - 1][0] + prices[i];\\n    dp[i][3] = dp[i - 1][2];\\n  }\\n  return Math.max(dp[len - 1][1], dp[len - 1][2], dp[len - 1][3]);\\n};\\n\\nconst max5 = maxProfit5([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\\nconsole.log(\"max5: \", max5);\\n')])])]), _c(\"p\", [_vm._v(\"// 股票--含有冷冻期_2\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('const maxProfit5_2 = (prices) => {\\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\\n  // 2:今天卖出股票\\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\\n  const len = prices.length;\\n  const dp = new Array(len).fill(0);\\n  for (let i = 1; i < len; i++) {\\n    const temp1 = dp[0];\\n    const temp2 = dp[2];\\n    dp[0] = Math.max(dp[0], Math.max(dp[1], dp[3]) - prices[i]);\\n    dp[1] = Math.max(dp[1], dp[3]);\\n    dp[2] = temp1 + prices[i];\\n    dp[3] = temp2;\\n  }\\n  return Math.max(...dp);\\n};\\n\\nconst max5_2 = maxProfit5_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\\nconsole.log(\"max5_2: \", max5_2);\\n')])])]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"给定一个含有 n 个正整数的数组和一个正整数 target 。\")])]), _c(\"p\", [_vm._v(\"找出该数组中满足其总和大于等于 target 的长度最小的 连续\\n子数组\\n子数组\\n子数组 是数组中连续的 非空 元素序列。\")]), _c(\"p\", [_vm._v(\"[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0\\n*/\\n//  长度最小的子数组\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var minSubArrayLen = function (target, nums) {\\n  let left = (right = 0),\\n    len = nums.length,\\n    sum = 0,\\n    res = len + 1;\\n  while (right < len) {\\n    sum += nums[right];\\n    while (sum >= target) {\\n      res = Math.min(res, right - left + 1);\\n      sum -= nums[left++];\\n    }\\n    right++;\\n  }\\n  return res > len ? 0 : res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_c(\"ol\", {\n    attrs: {\n      start: \"59\"\n    }\n  }, [_c(\"li\", [_vm._v(\"螺旋矩阵 II (https://leetcode.cn/problems/spiral-matrix-ii/description/)\")])])]), _c(\"li\", [_vm._v(\"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\")]), _c(\"li\")]), _c(\"p\", [_vm._v(\"*/\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var generateMatrix = function (n) {\\n  let starX = (startY = 0),\\n    offset = 1,\\n    loop = Math.floor(n / 2),\\n    mid = Math.floor(n / 2),\\n    count = 1;\\n  let res = Array(n)\\n    .fill(0)\\n    .map(() => Array(n).fill(0));\\n\\n  while (loop--) {\\n    let row = starX,\\n      col = startY;\\n    // 上行从左到右\\n    for (; col < n - offset; col++) {\\n      res[row][col] = count++;\\n    }\\n    // 右列从上到下\\n    for (; row < n - offset; row++) {\\n      res[row][col] = count++;\\n    }\\n    // 下行从右到左\\n    for (; col > startY; col--) {\\n      res[row][col] = count++;\\n    }\\n    // 左列从下到上\\n    for (; row > starX; row--) {\\n      res[row][col] = count++;\\n    }\\n    starX++;\\n    startY++;\\n    offset++;\\n  }\\n  if (n % 2 === 1) {\\n    res[mid][mid] = count;\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 链表\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"class ListNode {\\n  constructor(value, next) {\\n    this.val = value;\\n    this.next = next;\\n  }\\n}\\n\")])])]), _c(\"p\", [_vm._v(\"// 删除列表\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var removeElements = function (head, val) {\\n  const dummyHead = new ListNode(0, head);\\n  let cur = dummyHead;\\n  while (cur.next) {\\n    if (cur.next.val === val) {\\n      cur.next = cur.next.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n  }\\n  return dummyHead.next;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 设计链表\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var ListNode = function (val, next) {\\n  this.val = val === undefined ? 0 : val;\\n  this.next = next === undefined ? null : next;\\n};\\n\\nvar MyLinkedList = function () {\\n  this.size = 0;\\n  this.head = new ListNode(0);\\n};\\n\\n/**\\n * @param {number} index\\n * @return {number}\\n */\\nMyLinkedList.prototype.getNode = function (index) {\\n  if (index < 0 || index >= this.size) return -1;\\n  let cur = this.head;\\n  while (index-- >= 0) {\\n    cur = cur.next;\\n  }\\n  return cur.val;\\n};\\n\\nMyLinkedList.prototype.get = function (index) {\\n  return this.getNode(index);\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtHead = function (val) {\\n  this.addAtIndex(0, val);\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtTail = function (val) {\\n  this.addAtIndex(this.size, val);\\n};\\n\\n/**\\n * @param {number} index\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtIndex = function (index, val) {\\n  if (index > this.size) return;\\n  index = Math.max(0, index);\\n  this.size++;\\n  let cur = this.head;\\n  while (index--) {\\n    cur = cur.next;\\n  }\\n  let toAdd = new ListNode(val);\\n  toAdd.next = cur.next;\\n  cur.next = toAdd;\\n};\\n\\n/**\\n * @param {number} index\\n * @return {void}\\n */\\nMyLinkedList.prototype.deleteAtIndex = function (index) {\\n  if (index < 0 || index >= this.size) return;\\n  this.size--;\\n  let cur = this.head;\\n  while (index--) {\\n    cur = cur.next;\\n  }\\n  cur.next = cur.next.next;\\n};\\n\\n\")])])]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"翻转链表\")]), _c(\"li\", [_vm._v(\"@param {*} head\")]), _c(\"li\", [_vm._v(\"@returns\\n*/\\n//\\n// 双指针\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var reverseList = function (head) {\\n  if (!head || !head.next) return head;\\n  let pre = null,\\n    cur = head,\\n    temp = null;\\n  while (cur) {\\n    temp = cur.next;\\n    cur.next = pre;\\n    pre = cur;\\n    cur = temp;\\n  }\\n  return pre;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 翻转链表-递归1\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var reverse = function (pre, head) {\\n  if (!head) return pre;\\n  let temp = head.next;\\n  head.next = pre;\\n  pre = head;\\n  reverse(pre, temp);\\n};\\nvar reverseList = function (head) {\\n  reverse(null, head);\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 24. 两两交换链表中的节点\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var swapPairs = function (head) {\\n  let ret = new ListNode(0, head),\\n    temp = ret;\\n  while (temp.next && temp.next.next) {\\n    let cur = temp.next.next,\\n      pre = temp.next;\\n    pre.next = cur.next;\\n    cur.next = pre;\\n    temp.next = cur;\\n    temp = pre;\\n  }\\n  return ret.next;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 19. 删除链表的倒数第 N 个结点\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var removeNthFromEnd = function (head, n) {\\n  let ret = new ListNode(0, head),\\n    slow = (fast = ret);\\n  while (n--) {\\n    fast = fast.next;\\n  }\\n  while (fast.next !== null) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n  slow.next = slow.next.next;\\n  return ret.next;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 142. 环形链表 II (给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。)\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var detectCycle = function (head) {\\n  if (!head || !head.next) return null;\\n  let slow = (fast = head);\\n  while (fast && fast.next && fast.next.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    if (fast === slow) {\\n      slow = head;\\n      while (fast !== slow) {\\n        fast = fast.next;\\n        slow = slow.next;\\n      }\\n      return slow;\\n    }\\n  }\\n  return null;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 02.07. 链表相交 1\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var getIntersectionNode1 = function (headA, headB) {\\n  if (!headA || !headB) return null;\\n  let curA = headA,\\n    curB = headB;\\n  while (curA !== curB) {\\n    curA = curA ? curA.next : headB;\\n    curB = curB ? curB.next : headA;\\n  }\\n  return curA;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 02.07. 链表相交 2\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var getIntersectionNode2 = function (headA, headB) {\\n  if (!headA || !headB) return null;\\n  const visited = new Set();\\n  let temp = headA;\\n  while (temp) {\\n    visited.add(temp);\\n    temp = temp.next;\\n  }\\n  temp = headB;\\n  while (temp) {\\n    if (visited.has(temp)) return temp;\\n    temp = temp.next;\\n  }\\n  return null;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\\n// 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var isAnagram = function (s, t) {\\n  if (s.length !== t.length) return false;\\n  let ret = new Array(26).fill(0),\\n    base = \"a\".charCodeAt();\\n  for (const i of s) {\\n    ret[i.charCodeAt() - base]++;\\n  }\\n  for (const i of t) {\\n    if (!ret[i.charCodeAt() - base]) return false;\\n    ret[i.charCodeAt() - base]--;\\n  }\\n  return true;\\n};\\nvar isAnagram2 = function (s, t) {\\n  if (s.length !== t.length) return false;\\n  let ret = new Map();\\n  for (const i of s) {\\n    ret.set(i, (ret.get(i) || 0) + 1);\\n  }\\n  for (const i of t) {\\n    if (!ret.get(i)) return false;\\n    ret.set(i, ret.get(i) - 1);\\n  }\\n  return true;\\n};\\n')])])]), _c(\"p\", [_vm._v(\"// 349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的 交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\\n// https://leetcode.cn/problems/intersection-of-two-arrays/\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var intersection = function (nums1, nums2) {\\n  if (nums1.length < nums2.length) {\\n    [nums2, nums1] = [nums1, nums2];\\n  }\\n  let ret1 = new Set(nums1),\\n    ret2 = new Set();\\n  for (let i = 0; i < nums2.length; i++) {\\n    ret1.has(nums2[i]) && ret2.add(nums2[i]);\\n  }\\n  return Array.from(ret2);\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 202. 快乐数\\n//「快乐数」 定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\\n// 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\\n// 如果这个过程 结果为 1，那么这个数就是快乐数。\\n// 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var isHappy = function (n) {\\n  let m = new Set();\\n  let getSum = (num) => {\\n    let sum = 0;\\n    while (num) {\\n      sum += (num % 10) ** 2;\\n      num = Math.floor(num / 10);\\n    }\\n  };\\n  // 1\\n  // while(true) {\\n  //   if (m.has(n)) return false\\n  //   if (n === 1) return true\\n  //   n = getSum(n)\\n  //   m.add(n)\\n  // }\\n  // 2\\n  while (n !== 1 && !m.has(n)) {\\n    m.add(n);\\n    n = getSum(n);\\n  }\\n  return n === 1;\\n};\\nisHappy(19);\\n\")])])]), _c(\"p\", [_vm._v(\"// 1. 两数之和\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var twoSum = function (nums, target) {\\n  let has = {};\\n  for (let i = 0; i < nums.length; i++) {\\n    if (has[target - nums[i]] !== undefined) {\\n      return [i, has[target - nums[i]]];\\n    }\\n    has[nums[i]] = i;\\n  }\\n  return [];\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var fourSumCount = function (nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n  nums1.forEach((n1) =>\\n    nums2.forEach((n2) => map.set(n1 + n2, (map.get(n1 + n2) || 0) + 1))\\n  );\\n  let count = 0;\\n  for (let n3 of nums3) {\\n    for (let n4 of nums4) {\\n      if (map.has(-(n3 + n4))) {\\n        count += map.get(-(n3 + n4));\\n      }\\n    }\\n  }\\n  return count;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 383. 赎金信 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var canConstruct = function (ransomNote, magazine) {\\n  let strArr = Array(26).fill(0),\\n    base = \"a\".charCodeAt();\\n  for (let i of magazine) {\\n    strArr[i.charCodeAt() - base]++;\\n  }\\n  for (let u of ransomNote) {\\n    let index = u.charCodeAt() - base;\\n    if (!strArr[index]) return false;\\n    strArr[index]--;\\n  }\\n  return true;\\n};\\n')])])]), _c(\"p\", [_vm._v(\"// 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\\n// 你返回所有和为 0 且不重复的三元组。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var threeSum = function (nums) {\\n  let res = [],\\n    len = nums.length;\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < len; i++) {\\n    let l = i + 1,\\n      r = len - 1,\\n      iNum = nums[i];\\n    if (iNum > 0) return res;\\n    if (iNum === nums[i - 1]) continue;\\n    while (l < r) {\\n      let lNum = nums[l],\\n        rNum = nums[r],\\n        threeSum = iNum + lNum + rNum;\\n      if (threeSum < 0) l++;\\n      else if (threeSum > 0) r--;\\n      else {\\n        res.push([iNum, lNum, rNum]);\\n        while (l < r && nums[l] === nums[l + 1]) {\\n          l++;\\n        }\\n        while (l < r && nums[r] === nums[r - 1]) {\\n          r--;\\n        }\\n        l++;\\n        r--;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var fourSum = function (nums, target) {\\n  let res = [],\\n    len = nums.length;\\n  if (len < 4) return [];\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < len - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n\\n    for (let j = i + 1; j < len - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) continue;\\n\\n      let l = j + 1,\\n        r = len - 1;\\n      while (l < r) {\\n        const sum = nums[i] + nums[j] + nums[l] + nums[r];\\n        if (sum > target) r--;\\n        else if (sum < target) l++;\\n        else {\\n          res.push([nums[i], nums[j], nums[l], nums[r]]);\\n          // while (l < r && nums[l] === nums[l + 1]) {\\n          //   l++\\n          // }\\n          // while (l < r && nums[r] === nums[r - 1]) {\\n          //   r--;\\n          // }\\n          // l++\\n          // r--\\n          while (l < r && nums[l] === nums[++l]);\\n          while (l < r && nums[r] === nums[--r]);\\n        }\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 344. 反转字符串\\n// 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var reverseString = function (s) {\\n  // let l = -1,r = s.length;\\n  // while(++l < --r) [s[l], s[r]] = [s[r], s[l]]\\n  let l = 0,\\n    r = s.length - 1,\\n    temp = null;\\n  while (l < r) {\\n    temp = s[l];\\n    s[l] = s[r];\\n    s[r] = temp;\\n    l++;\\n    r--;\\n  }\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 541. 反转字符串 II\\n// 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var reverseStr = function (s, k) {\\n  let len = s.length,\\n    resArr = s.split(\"\");\\n  // for (let i = 0; i < len; i += 2 * k) {\\n  //   let l = i - 1,\\n  //     r = i + k > len ? len : i + k;\\n  //   while (++l < --r) [[resArr[l]], resArr[r]] = [[resArr[r]], resArr[l]];\\n  // }\\n  for (let i = 0; i < len; i += 2 * k) {\\n    let l = i - 1,\\n      r = i + k > len ? len : i + k,\\n      temp = null;\\n    while (++l < --r) {\\n      temp = resArr[l];\\n      resArr[l] = resArr[r];\\n      resArr[r] = temp;\\n    }\\n  }\\n  return resArr.join(\"\");\\n};\\n')])])]), _c(\"p\", [_vm._v('// 替换数字（第八期模拟笔试）\\n// 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 \"a1b2c3\"，函数应该将其转换为 \"anumberbnumbercnumber\"。')]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('let numberToStringFn = function (str) {\\n  let num0 = \"0\".charCodeAt(),\\n    num9 = \"9\".charCodeAt(),\\n    a = \"a\".charCodeAt(),\\n    z = \"z\".charCodeAt(),\\n    len = str.length,\\n    n = 0;\\n  let isNumber = (code) => {\\n    code = code.charCodeAt();\\n    return code >= num0 && code <= num9;\\n  };\\n  let isAz = (code) => {\\n    code = code.charCodeAt();\\n    return code >= a && code <= z;\\n  };\\n  // 计算新数组长度\\n  for (let i = 0; i < len; i++) {\\n    if (isNumber(str[i])) {\\n      n += 6;\\n    } else if (isAz(str[i])) {\\n      n += 1;\\n    } else {\\n      n += 1;\\n    }\\n  }\\n  let newArr = Array(n).fill(\"\"),\\n    index = n - 1;\\n  for (let i = len - 1; i >= 0; i--) {\\n    if (isAz(str[i])) {\\n      // 字符串\\n      newArr[index] = str[i];\\n      index--;\\n    } else if (isNumber(str[i])) {\\n      // number\\n      newArr[index] = \"r\";\\n      newArr[index - 1] = \"e\";\\n      newArr[index - 2] = \"b\";\\n      newArr[index - 3] = \"m\";\\n      newArr[index - 4] = \"u\";\\n      newArr[index - 5] = \"n\";\\n      index -= 6;\\n    }\\n  }\\n  console.log(newArr.join(\"\"));\\n  console.log(newArr.join(\"\").length);\\n};\\n\\nnumberToStringFn(\"12jsd3k2n5k6k9\");\\n')])])]), _c(\"p\", [_vm._v(\"// 151. 反转字符串中的单词\\n/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\\n*/\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var reverseWords = function (s) {\\n  // function removeExtraSpaces(strArr) {\\n  //   let slowIndex = 0, fastIndex = 0;\\n  //   while(fastIndex < strArr.length) {\\n  //     if (strArr[fastIndex] === ' ' && (fastIndex === 0 || strArr[fastIndex - 1] === ' ')) {\\n  //       fastIndex++\\n  //     } else {\\n  //       strArr[slowIndex++] = strArr[fastIndex++]\\n  //     }\\n  //   }\\n  //   strArr.length = strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex\\n  // }\\n  // function reverse(strArr, start, end) {\\n  //   let l = start,r = end;\\n  //   while(l < r) {\\n  //     [strArr[r], strArr[l]] = [strArr[l], strArr[r]]\\n  //     l++\\n  //     r--\\n  //   }\\n  // }\\n\\n  // const strArr = Array.from(s)\\n  // removeExtraSpaces(strArr)\\n  // // 翻转\\n  // reverse(strArr, 0, strArr.length - 1)\\n  // let start = 0\\n  // for(let i = 0; i <= strArr.length;i++) {\\n  //   if (strArr[i] === ' ' || i === strArr.length) {\\n  //     reverse(strArr, start, i - 1)\\n  //     start = i + 1\\n  //   }\\n  // }\\n  // return strArr.join('')\\n\\n  // 2--------\\n  const strArr = s.trim().split(/\\\\s+/);\\n  let i = 0,\\n    j = strArr.length - 1;\\n  for (; i <= j; i++, j--) {\\n    // 1----------\\n    // [strArr[j], strArr[i]] = [strArr[i], strArr[j]];\\n\\n    // 2----------\\n    let tmp = sArr[i];\\n    sArr[i] = sArr[j];\\n    sArr[j] = tmp;\\n  }\\n  return strArr.join(\\\" \\\");\\n};\\nreverseWords(\\\"asdf sd adf sd fe\\\");\\n\\n\")])])]), _c(\"p\", [_vm._v(\"// 右旋字符串\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('function reverseStrFn(arr, start, end) {\\n  let l = start,\\n    r = end;\\n  while (l < r) {\\n    [arr[r], arr[l]] = [arr[l], arr[r]];\\n    l++;\\n    r--;\\n  }\\n  return arr;\\n}\\n\\nfunction reVerArr(arr, n) {\\n  reverseStrFn(arr, 0, arr.length - 1);\\n  reverseStrFn(arr, 0, n - 1);\\n  reverseStrFn(arr, n, arr.length - 1);\\n  console.log(\"arr: \", arr.join(\"\"));\\n  return arr.join(\"\");\\n}\\nlet arr = Array.from(\"asbejkl\");\\nreVerArr(arr, 3);\\n')])])]), _c(\"p\", [_vm._v(\"// 28. 找出字符串中第一个匹配项的下标\\n/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\")]), _c(\"li\", [_vm._v(\"@param {*} haystack\")]), _c(\"li\", [_vm._v(\"@param {*} needle\\n*/\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var strStr = function (haystack, needle) {\\n if (!needle.length) return 0;\\n var getNext = (needle) => {\\n   let j = 0,\\n     next = [];\\n   next[0] = 0;\\n   for (let i = 1; i < needle.length; i++) {\\n     while (j > 0 && needle[i] !== needle[j]) {\\n       console.log(\"j: \", j);\\n       j = next[j - 1];\\n     }\\n     if (needle[i] === needle[j]) {\\n       j++;\\n     }\\n     next[i] = j;\\n   }\\n   return next;\\n };\\n let next = getNext(needle);\\n let j = 0;\\n for (let i = 0; i < haystack.length; i++) {\\n   while (j > 0 && haystack[i] !== needle[j]) {\\n     j = next[j - 1];\\n   }\\n   if (haystack[i] === needle[j]) {\\n     j++;\\n   }\\n   if (j === needle.length) {\\n     return i + 1 - needle.length;\\n   }\\n }\\n return -1;\\n};\\n\\nconst f = strStr(\"6sadbutsad\", \"sad\");\\nconsole.log(\"f: \", f);\\n')])])]), _c(\"p\", [_vm._v(\"// 459.重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var repeatedSubstringPattern = function (s) {\\n  let len = s.length;\\n  if (!len) return false;\\n  let getNext = (s) => {\\n    let j = 0,\\n      next = [0];\\n    for (let i = 1; i < s.length; i++) {\\n      while (j > 0 && s[i] !== s[j]) {\\n        j = next[j - 1];\\n      }\\n      if (s[i] === s[j]) {\\n        j++;\\n      }\\n      next.push(j);\\n    }\\n    return next;\\n  };\\n  let next = getNext(s),\\n    len2 = next.length;\\n  return next[len2 - 1] !== 0 && len % (len - next[len2 - 1]) === 0;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var removeElement = function (nums, val) {\\n  // let k = 0\\n  // for(let i = 0; i < nums.length; i++) {\\n  //   if (nums[i] !== val) {\\n  //     nums[k++] = nums[i]\\n  //   }\\n  // }\\n  // // nums.length = k\\n  // return k\\n  let l = 0,\\n    r = nums.length;\\n  while (l < r) {\\n    if (nums[l] === val) {\\n      nums[l] = nums[--r];\\n    } else {\\n      l++;\\n    }\\n  }\\n  nums.length = l;\\n  console.log(\"nums: \", nums);\\n  return l;\\n};\\nremoveElement([1, 2, 3, 3, 5, 5], 5);\\n')])])]), _c(\"p\", [_vm._v(\"// 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var MyQueueFn = () => {\\n  var MyQueue = function () {\\n    this.stackIn = [];\\n    this.stackOut = [];\\n  };\\n\\n  /**\\n   * @param {number} x\\n   * @return {void}\\n   */\\n  MyQueue.prototype.push = function (x) {\\n    this.stackIn.push(x);\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyQueue.prototype.pop = function () {\\n    const size = this.stackOut.length;\\n    if (size) {\\n      return this.stackOut.pop();\\n    }\\n    while (this.stackIn.length) {\\n      this.stackOut.push(this.stackIn.pop());\\n    }\\n    return this.stackOut.pop();\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyQueue.prototype.peek = function () {\\n    const x = this.pop();\\n    this.stackOut.push(x);\\n    return x;\\n  };\\n\\n  /**\\n   * @return {boolean}\\n   */\\n  MyQueue.prototype.empty = function () {\\n    return !this.stackIn.length && !this.stackOut.length;\\n  };\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 225. 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var MyStackFn = () => {\\n  var MyStack = function () {\\n    this.queue1 = [];\\n    this.queue2 = [];\\n  };\\n  /**\\n   * @param {number} x\\n   * @return {void}\\n   */\\n  MyStack.prototype.push = function (x) {\\n    this.queue1.push(x);\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyStack.prototype.pop = function () {\\n    if (!this.queue1.length) {\\n      [this.queue2, this.queue1] = [this.queue1, this.queue2];\\n    }\\n    while (this.queue1.length > 1) {\\n      this.queue2.push(this.queue1.shift());\\n    }\\n    return this.queue1.shift();\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyStack.prototype.top = function () {\\n    var x = this.pop();\\n    this.queue1.push(x);\\n    return x;\\n  };\\n\\n  /**\\n   * @return {boolean}\\n   */\\n  MyStack.prototype.empty = function () {\\n    return !this.queue1.length && !this.queue2.length;\\n  };\\n};\\n\\n// 用一个队列实现-------\\nclass MyStack {\\n  constructor() {\\n    this.queue = [];\\n  }\\n\\n  push(x) {\\n    this.queue.push(x);\\n  }\\n\\n  pop() {\\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\\n    let size = this.queue.length;\\n    while (size-- > 1) {\\n      this.queue.push(this.queue.shift());\\n    }\\n    // 移除并返回最后一个元素\\n    return this.queue.shift();\\n  }\\n  top() {\\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\\n    const x = this.pop();\\n    this.queue.push(x);\\n  }\\n  empty() {\\n    return this.queue.length === 0;\\n  }\\n}\\n\\n// 示例用法：\\nconst stack = new MyStack();\\nstack.push(1);\\nstack.push(2);\\nconsole.log(stack.top()); // 输出 2\\nconsole.log(stack.pop()); // 输出 2\\nconsole.log(stack.empty()); // 输出 false\\n\")])])]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"有效字符串需满足：\\n左括号必须用相同类型的右括号闭合。\\n左括号必须以正确的顺序闭合。\\n每个右括号都有一个对应的相同类型的左括号。\\n*/\\n// 20. 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var isValid = function (s) {\\n  // let list = [];\\n  // for(let i of s) {\\n  //   switch (i) {\\n  //     case \\'(\\':\\n  //       list.push(\\')\\')\\n  //       break;\\n  //     case \\'[\\':\\n  //       list.push(\\']\\')\\n  //       break;\\n  //     case \\'{\\':\\n  //       list.push(\\'}\\')\\n  //       break;\\n  //     default:\\n  //       if (i !== list.pop()) return false\\n  //       break;\\n  //   }\\n  // }\\n  // return !list.length\\n  let list = [],\\n    map = {\\n      \"(\": \")\",\\n      \"[\": \"]\",\\n      \"{\": \"}\",\\n    };\\n  for (let i of s) {\\n    if (map[i]) {\\n      list.push(i);\\n      continue;\\n    }\\n    if (map[list.pop()] !== i) return false;\\n  }\\n  return !list.length;\\n};\\nisValid(\"((\");\\n')])])]), _c(\"p\", [_vm._v(\"// 1047. 删除字符串中的所有相邻重复项\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var removeDuplicates = function (s) {\\n  // var list = []\\n  // for(let i of s) {\\n  //   let lastVal = list.length ? list[list.length - 1] : null\\n  //   if (i === lastVal) {\\n  //     list.pop()\\n  //   } else {\\n  //     list.push(i)\\n  //   }\\n  // }\\n  // return list.join(\\'\\')\\n  let list = [...s],\\n    top = -1;\\n  for (let i of s) {\\n    if (top === -1 || list[top] !== i) {\\n      list[++top] = i;\\n    } else {\\n      top--;\\n    }\\n  }\\n  list.length = top + 1;\\n  console.log(\"list.join\", list.join(\"\"));\\n  return list.join(\"\");\\n};\\nremoveDuplicates(\"dbccab\");\\n')])])]), _c(\"p\", [_vm._v(\"// 150. 逆波兰表达式求值 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var evalRPN = function (tokens) {\\n  let stack = [];\\n  for (const token of tokens) {\\n    if (isNaN(Number(token))) {\\n      // 重点 isNaN()\\n      const n2 = stack.pop(); // 出栈两个数字\\n      const n1 = stack.pop();\\n      switch (token) {\\n        case \"+\":\\n          stack.push(n1 + n2);\\n          break;\\n        case \"-\":\\n          stack.push(n1 - n2);\\n          break;\\n        case \"*\":\\n          stack.push(n1 * n2);\\n          break;\\n        case \"/\":\\n          const st = (n1 / n2) | 0; // 重点 | 0\\n          stack.push(st);\\n          break;\\n      }\\n    } else {\\n      stack.push(Number(token));\\n    }\\n  }\\n  console.log(\"stack[0]: \", stack[0]);\\n  return stack[0];\\n};\\n\\nevalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]);\\n')])])]), _c(\"p\", [_vm._v(\"// 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。\")]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"@param {number[]} nums\")]), _c(\"li\", [_vm._v(\"@param {number} k\")]), _c(\"li\", [_vm._v(\"@return {number[]}\\n*/\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var maxSlidingWindow = function (nums, k) {\\n class MonoQueue {\\n   queue;\\n   constructor() {\\n     this.queue = [];\\n   }\\n   enqueue(value) {\\n     let back = this.queue[this.queue.length - 1];\\n     while (back !== undefined && back < value) {\\n       this.queue.pop();\\n       back = this.queue[this.queue.length - 1];\\n     }\\n     this.queue.push(value);\\n   }\\n   dequeue(value) {\\n     const front = this.front();\\n     if (front === value) {\\n       this.queue.shift();\\n     }\\n   }\\n   front() {\\n     return this.queue[0];\\n   }\\n }\\n const helpQueue = new MonoQueue();\\n let i = 0,\\n   j = 0,\\n   resArr = [];\\n // 先将前k个参数循环一遍\\n while (j < k) {\\n   helpQueue.enqueue(nums[j++]);\\n }\\n resArr.push(helpQueue.front());\\n // 再让i从0开始 如果有一样的走过的参数从列表里面删除掉\\n while (j < nums.length) {\\n   helpQueue.enqueue(nums[j++]);\\n   helpQueue.dequeue(nums[i++]);\\n   resArr.push(helpQueue.front());\\n }\\n return resArr;\\n};\\nmaxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);\\n\")])])]), _c(\"p\", [_vm._v(\"/**\\n*\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"在 JavaScript 中，小顶堆通常使用数组来实现。数组表示小顶堆时，元素按层级顺序存储，\")]), _c(\"li\", [_vm._v(\"即父节点的索引为 i，其左子节点的索引为 2*i + 1，\")]), _c(\"li\", [_vm._v(\"右子节点的索引为 2*i + 2。这种存储方式使得堆的操作非常高效。\")]), _c(\"li\"), _c(\"li\", [_vm._v(\"数组表示的具体规则\\n根节点：根节点在数组中的索引为 0。\\n左子节点：对于索引为 i 的节点，左子节点的索引为 2\"), _c(\"em\", [_vm._v(\"i + 1。\\n右子节点：对于索引为 i 的节点，右子节点的索引为 2\")]), _vm._v(\"i + 2。\\n父节点：对于索引为 i 的节点，父节点的索引为 Math.floor((i - 1) / 2)。\")]), _c(\"li\")]), _c(\"p\", [_vm._v(\"*/\")]), _c(\"p\", [_vm._v(\"// js实现小顶堆\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"class MinHeap {\\n  constructor(compareFn) {\\n    this.head = [];\\n    this.compareFn = compareFn;\\n  }\\n  getParentIndex(index) {\\n    return Math.floor((index - 1) / 2);\\n  }\\n  getLeftChildIndex(index) {\\n    return index * 2 + 1;\\n  }\\n  getRightChildIndex(index) {\\n    return index * 2 + 2;\\n  }\\n  swap(index1, index2) {\\n    [this.head[index2], this.head[index1]] = [\\n      this.head[index1],\\n      this.head[index2],\\n    ];\\n  }\\n  compare(index1, index2) {\\n    if (this.head[index1] === undefined) return 1;\\n    if (this.head[index2] === undefined) return -1;\\n    return this.compareFn(this.head[index1], this.head[index2]);\\n  }\\n  insert(val) {\\n    this.head.push(val);\\n    this.headPiFyUp();\\n  }\\n  // 向上堆积\\n  headPiFyUp() {\\n    let index = this.head.length - 1;\\n    while (index > 0) {\\n      let parentIndex = this.getParentIndex(index);\\n      //  this.head[index] < this.head[parentIndex]\\n      if (this.compare(index, parentIndex) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  remove() {\\n    let len = this.head.length;\\n    if (!len) return null;\\n    if (len === 1) return this.head.pop();\\n    const root = this.head[0];\\n    this.head[0] = this.head.pop();\\n    this.headPiFyDown(0);\\n    return root;\\n  }\\n  // 向下堆积\\n  headPiFyDown(index) {\\n    let smallest = index;\\n    const leftChildrenIndex = this.getLeftChildIndex(index);\\n    const rightChildrenIndex = this.getRightChildIndex(index);\\n    // if (leftChildrenIndex < this.head.length && this.head[leftChildrenIndex] < this.head[smallest]) {\\n    if (\\n      leftChildrenIndex < this.head.length &&\\n      this.compare(leftChildrenIndex, smallest) < 0\\n    ) {\\n      smallest = leftChildrenIndex;\\n    }\\n    // if (rightChildrenIndex < this.head.length && this.head[rightChildrenIndex] < this.head[smallest]) {\\n    if (\\n      rightChildrenIndex < this.head.length &&\\n      this.compare(rightChildrenIndex, smallest) < 0\\n    ) {\\n      smallest = rightChildrenIndex;\\n    }\\n    if (smallest !== index) {\\n      // 说明进行了转换\\n      this.swap(index, smallest);\\n      this.headPiFyDown(smallest);\\n    }\\n  }\\n  getMin() {\\n    return this.head[0];\\n  }\\n  size() {\\n    return this.head.length;\\n  }\\n  isEmpty() {\\n    return !this.head.length;\\n  }\\n  buildHeap(arr) {\\n    this.head = arr;\\n    for (let i = Math.floor(this.head.length / 2) - 1; i >= 0; i--) {\\n      this.headPiFyDown(i);\\n    }\\n  }\\n  printHeap() {\\n    console.log(this.head);\\n  }\\n}\\n\\n// const testMinHeap = () => {\\n//   const minHeap = new MinHeap((a, b) => a - b)\\n//   minHeap.insert(10)\\n//   minHeap.insert(1)\\n//   minHeap.insert(2)\\n//   minHeap.insert(3)\\n//   minHeap.insert(4)\\n//   minHeap.printHeap()\\n\\n//   const minVal1 = minHeap.getMin()\\n//   console.log('minVal1: ', minVal1);\\n\\n//   minHeap.remove()\\n//   minHeap.printHeap()\\n\\n//   const minVal2 = minHeap.getMin()\\n//   console.log('minVal2: ', minVal2);\\n\\n//   minHeap.insert(5)\\n//   minHeap.printHeap()\\n\\n//   const minVal3 = minHeap.getMin()\\n//   console.log('minVal3: ', minVal3);\\n// }\\n// testMinHeap()\\n\")])])]), _c(\"p\", [_vm._v(\"// 347. 前 K 个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('var topKFrequent = function (nums, k) {\\n  const map = new Map();\\n  for (const i of nums) {\\n    map.set(i, (map.get(i) || 0) + 1);\\n  }\\n\\n  const heap = new MinHeap((a, b) => a[1] - b[1]);\\n\\n  for (const i of map.entries()) {\\n    heap.insert(i);\\n    if (heap.size() > k) {\\n      heap.remove();\\n    }\\n  }\\n  const res = [];\\n  heap.printHeap();\\n  for (let i = heap.size() - 1; i >= 0; i--) {\\n    res.push(heap.remove()[0]);\\n  }\\n  console.log(\"res: \", res);\\n  return res;\\n};\\n\\ntopKFrequent([1, 1, 1, 2, 2, 3], 2);\\n\\nconst topKFrequent2 = (nums, k) => {\\n  const map = new Map();\\n  for (const i of nums) {\\n    map.set(i, (map.get(i) || 0) + 1);\\n  }\\n  //返回一个按出现次数降序的二维数组\\n  let sortArray = Array.from(map).sort((a, b) => b[1] - a[1]),\\n    res = [];\\n  for (let i = 0; i < k; i++) {\\n    res.push(sortArray[i][0]);\\n  }\\n  console.log(\"res: \", res);\\n  return res;\\n};\\ntopKFrequent2([1, 1, 1, 2, 2, 3], 2);\\n\\n')])])]), _c(\"p\", [_vm._v(\"// 二叉树节点类\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('class TreeNode {\\n  constructor(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n  }\\n}\\nclass BinaryTree {\\n  constructor() {\\n    this.root = null;\\n  }\\n  insert(value) {\\n    const newNode = new TreeNode(value);\\n    if (this.root === null) {\\n      this.root = newNode;\\n    } else {\\n      this.insertNode(this.root, newNode);\\n    }\\n  }\\n  insertNode(node, newNode) {\\n    if (newNode.value < node.value) {\\n      // 新节点放到left\\n      if (node.left === null) {\\n        node.left = newNode;\\n      } else {\\n        this.insertNode(node.left, newNode);\\n      }\\n    } else {\\n      // 新节点放到right\\n      if (node.right === null) {\\n        node.right = newNode;\\n      } else {\\n        this.insertNode(node.right, newNode);\\n      }\\n    }\\n  }\\n  search(value) {\\n    return this.searchNode(this.root, value);\\n  }\\n  searchNode(root, value) {\\n    if (root === null) return false;\\n    if (value < root.value) {\\n      this.searchNode(root.left, value);\\n    } else if (value > root.value) {\\n      this.searchNode(root.right, value);\\n    } else {\\n      return true;\\n    }\\n  }\\n  /**\\n   * \\n   * 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式\\n    前序遍历：中左右\\n    中序遍历：左中右\\n    后序遍历：左右中\\n   */\\n  // 前序遍历\\n  preOrder(node = this.root) {\\n    if (node !== null) {\\n      console.log(node.value);\\n      this.preOrder(node.left);\\n      this.preOrder(node.right);\\n    }\\n  }\\n  // 中序遍历\\n  inOrder(node = this.root) {\\n    if (node !== null) {\\n      this.preOrder(node.left);\\n      console.log(node.value);\\n      this.preOrder(node.right);\\n    }\\n  }\\n  // 后序遍历\\n  postOrder(node = this.root) {\\n    if (node !== null) {\\n      this.preOrder(node.left);\\n      this.preOrder(node.right);\\n      console.log(node.value);\\n    }\\n  }\\n}\\n\\nconst treeTestFn = () => {\\n  const tree = new BinaryTree();\\n  tree.insert(7);\\n  tree.insert(4);\\n  tree.insert(9);\\n  tree.insert(1);\\n  tree.insert(6);\\n  tree.insert(8);\\n  tree.insert(10);\\n\\n  console.log(\"中序遍历\");\\n  tree.inOrder();\\n\\n  console.log(\"前序遍历\");\\n  tree.preOrderOrder();\\n\\n  console.log(\"后序遍历\");\\n  tree.postOrder();\\n\\n  console.log(\"查找节点\");\\n  console.log(tree.search(6));\\n  console.log(tree.search(15));\\n};\\ntreeTestFn();\\n\\nconst binaryTreeTraversal2 = () => {\\n  // 迭代法遍历\\n  // ---前序遍历---: (中左右) 栈进入顺序 右 -> 左; 出栈  中 -> 左 -> 右\\n  const preOrderTraversal = (root) => {\\n    let res = [];\\n    if (!root) return res;\\n    let stack = [root],\\n      cur = null;\\n    while (stack.length) {\\n      cur = stack.pop();\\n      res.push(cur.val);\\n      cur.right && stack.push(cur.right);\\n      cur.left && stack.push(cur.left);\\n    }\\n    return res;\\n  };\\n  // ---前序遍历--- 中左右  压入栈右->左->中; 出栈 中->左->右\\n  // const preOrderTraversal = (root) => {\\n  //   let res = [],\\n  //     stack = [root];\\n  //   while (stack.length) {\\n  //     const node = stack.pop();\\n  //     if (!node) {\\n  //       res.push(stack.pop().val);\\n  //       continue;\\n  //     }\\n  //     node.right && stack.push(node.right); // 右\\n  //     node.left && stack.push(node.left); // 左\\n  //     stack.push(node); // 中\\n  //     stack.push(null);\\n  //   }\\n  //   return res;\\n  // };\\n\\n  // ---中序遍历---: (左中右) 入栈 左 -> 右;  出栈 左 -> 中 -> 右\\n  const inOrderTraversal = (root) => {\\n    if (!root) return [];\\n    let res = [],\\n      stack = [],\\n      cur = root;\\n    do {\\n      if (cur) {\\n        stack.push(cur);\\n        cur = cur.left;\\n      } else {\\n        cur = stack.pop();\\n        res.push(cur.val);\\n        cur = cur.right;\\n      }\\n    } while (stack.length || cur);\\n    return res;\\n  };\\n\\n  // ---后序遍历---: (左右中) 栈进入顺序 左 -> 右;  出栈  中 -> 右 -> 左 结果翻转\\n  const postOrderTraversal = (root) => {\\n    let res = [];\\n    if (!root) return res;\\n    let stack = [root],\\n      cur = null;\\n    while (stack.length) {\\n      cur = stack.pop();\\n      res.push(cur.val);\\n      cur.left && stack.push(cur.left);\\n      cur.right && stack.push(cur.right);\\n    }\\n    return res.reverse();\\n  };\\n  // ---后续遍历--- 左右中\\n  // const postOrderTraversal_2 = (root) => {\\n  //   let res = [];\\n  //   if (!root) return res;\\n  //   let stack = [root],\\n  //     visited = new Set();\\n\\n  //   while (stack.length) {\\n  //     const node = stack[stack.length - 1];\\n  //     if (node.left && !visited.has(node.left)) {\\n  //       stack.push(node.left);\\n  //     } else if (node.right && !visited.has(node.right)) {\\n  //       stack.push(node.right);\\n  //     } else {\\n  //       res.push(node.val);\\n  //       visited.add(node);\\n  //       stack.pop();\\n  //     }\\n  //   }\\n  //   return res;\\n  // };\\n};\\n\\n// 示例二叉树结构\\nclass TreeNode {\\n  constructor(val, left = null, right = null) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n  }\\n}\\n\\nconst root = new TreeNode(1);\\nroot.left = new TreeNode(2);\\nroot.right = new TreeNode(3);\\nroot.left.left = new TreeNode(4);\\nroot.left.right = new TreeNode(5);\\nroot.right.left = new TreeNode(6);\\nroot.right.right = new TreeNode(7);\\n\\n')])])]), _c(\"p\", [_vm._v(\"// 测试前序遍历方法\")]), _c(\"p\", [_vm._v(\"// 102.二叉树的层序遍历次  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const levelOrder = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let curLevel = [],\\n      len = queue.length;\\n    for (let i = 0; i < len; i++) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    // res.push(curLevel);\\n    res.unshift(curLevel);\\n  }\\n  return res;\\n};\\n// 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\\nconst levelOrderBottom = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let curLevel = [],\\n      len = queue.length;\\n    while (len--) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      // 把下一层级的左右节点存入queue队列\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.unshift(curLevel);\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 199.二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v('class TreeNode {\\n  constructor(val, left = null, right = null) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n  }\\n}\\n\\nconst root = new TreeNode(1);\\nroot.left = new TreeNode(2);\\nroot.right = new TreeNode(3);\\nroot.left.left = new TreeNode(4);\\nroot.left.right = new TreeNode(5);\\nroot.right.left = new TreeNode(6);\\nroot.right.right = new TreeNode(7);\\n\\nconst rightSideView = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length;\\n    while (len--) {\\n      const node = queue.shift();\\n      if (!len) {\\n        res.push(node.val);\\n      }\\n      // 把下一层级的左右节点存入queue队列\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n  }\\n  return res;\\n};\\nconsole.log(\"rightSideView(root): \", rightSideView(root));\\n')])])]), _c(\"p\", [_vm._v(\"// 637.二叉树的层平均值  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const averageOfLevels = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let sum = 0,\\n      curLen = queue.length,\\n      len = curLen;\\n    while (len--) {\\n      const node = queue.shift();\\n      sum += node.val;\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.push(sum / curLen);\\n  }\\n  return res;\\n};\\n\\n\")])])]), _c(\"p\", [_vm._v(\"/**\")]), _c(\"ul\", [_c(\"li\", [_c(\"ol\", [_c(\"li\", [_vm._v(\"广度优先搜索（BFS）需要先进先出（FIFO）的队列行为，以确保节点按层次顺序被处理。这就是为什么 shift() 被用于 BFS 的原因\")])])]), _c(\"li\", [_c(\"ol\", {\n    attrs: {\n      start: \"2\"\n    }\n  }, [_c(\"li\", [_vm._v(\"如果使用 pop()，队列将变成后进先出（LIFO）的行为，这是深度优先搜索（DFS）的特性，而不是广度优先搜索。\\n*/\")])])])]), _c(\"p\", [_vm._v(\"// 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const levelOrderN = function (root) {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length,\\n      curLevel = [];\\n    while (len--) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      for (let item of node.children) {\\n        item && queue.push(item);\\n      }\\n    }\\n    res.push(curLevel);\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 515. 在每个树行中找最大值 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const largestValues = function (root) {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length,\\n      max = -Infinity;\\n    while (len--) {\\n      const node = queue.shift();\\n      max = Math.max(max, node.val);\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.push(max);\\n  }\\n  return res;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 116.填充每个节点的下一个右侧节点指针\\n/**\")]), _c(\"ul\", [_c(\"li\", [_vm._v(\"给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\\nstruct Node {\\nint val;\\nNode *left;\\nNode *right;\\nNode *next;\\n}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。\\n*/\")])]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const connect = function (root) {\\n if (!root) return root;\\n let queue = [root];\\n while (queue.length) {\\n   let len = queue.length;\\n   while (len--) {\\n     const node = queue.shift();\\n     if (len > 0) {\\n       node.next = queue[0];\\n     }\\n     node.left && queue.push(node.left);\\n     node.right && queue.push(node.right);\\n   }\\n }\\n return root;\\n};\\n\")])])]), _c(\"p\", [_vm._v(\"// 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const maxDepth = function (root) {\\n  let max = 0\\n  if (!root) return max;\\n  let queue = [root];\\n  while (queue.length) {\\n    let len = queue.length;\\n    max++\\n    while (len--) {\\n      const node = queue.shift();\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n  }\\n  return max;\\n}\\n\")])])]), _c(\"p\", [_vm._v(\"// 111.二叉树的最小深度\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"const minDepth = function(root) {\\n  let min = 0,queue = [root]\\n  if (!root) return min\\n  while(queue.length) {\\n    let len = queue.length\\n    min++\\n    while(len--) {\\n      const node = queue.shift()\\n      if (!node.left && !node.right) return min\\n      node.left && queue.push(node.left)\\n      node.right && queue.push(node.right)\\n    }\\n  }\\n  return min\\n}\\n\")])])]), _c(\"p\", [_vm._v(\"// 翻转二叉树\\n// 递归\")]), _c(\"div\", {\n    staticClass: \"language- extra-class\"\n  }, [_c(\"pre\", {\n    pre: true,\n    attrs: {\n      class: \"language-text\"\n    }\n  }, [_c(\"code\", [_vm._v(\"var invertTree = function(root) {\\n  if(root == null) return root\\n  const rightNode = root.right\\n  root.right = invertTree(root.left)\\n  root.left = invertTree(rightNode)\\n  return root\\n}\\n\\n// 层序遍历\\nvar invertTree2 = function(root) {\\n  const invertNode = (root, left, right) => {\\n    const temp = left\\n    root.left = right\\n    root.right = temp\\n  }\\n  if (root == null) return root\\n  let queue = [root]\\n  while(queue.length) {\\n    let len = queue.length\\n    if (len--) {\\n      const node = queue.shift()\\n      invertNode(node, node.left, node.right)\\n      node.left && queue.push(node.left)\\n      node.right && queue.push(node.right)\\n    }\\n  }\\n  return root\\n}\\n// 迭代遍历 (前序遍历中左右); 入栈顺序为：右左 (栈是后进先出原则)\\nvar invertTree3 = function(root) {\\n  if (root == null) return root\\n  let queue = [root]\\n  while (queue.length) {\\n    let curNode = queue.pop()\\n    const temp = curNode.left\\n    curNode.left = curNode.right\\n    curNode.right = temp\\n\\n    // 将右子节点入栈\\n    if (curNode.right) queue.push(curNode.right)\\n\\n    // 将右子节点入栈\\n    if (curNode.left) queue.push(curNode.left)\\n  }\\n  return root\\n}\\n\")])])])]);\n}];\nrender._withStripped = true;\nexport { render, staticRenderFns };",{"version":3,"sources":["docs/pages/javascript/algorithm.md"],"names":["render","_vm","_c","_self","_m","staticRenderFns","staticClass","attrs","id","href","_v","pre","class","start","_withStripped"],"mappings":"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","sourceRoot":"/Users/mypro/history/gitpro/hxl888.github.io","sourcesContent":["var render = function render() {\n  var _vm = this,\n    _c = _vm._self._c\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function () {\n    var _vm = this,\n      _c = _vm._self._c\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"js-算法\" } }, [\n        _c(\"a\", { staticClass: \"header-anchor\", attrs: { href: \"#js-算法\" } }, [\n          _vm._v(\"#\"),\n        ]),\n        _vm._v(\" js 算法\"),\n      ]),\n      _c(\"p\", [_vm._v(\"// 股票买卖1-买卖一次\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'const maxProFit = (prices) => {\\n  const len = prices.length;\\n  const dp = new Array(len).fill([0, 0]);\\n  dp[0] = [-prices[0], 0];\\n  for (let i = 1; i < len; i++) {\\n    dp[i] = [\\n      Math.max(dp[i - 1][0], -prices[i]),\\n      Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]),\\n    ];\\n  }\\n  return dp[len - 1][1];\\n};\\nconst max = maxProFit([1, 2, 8, 2, 6]);\\nconsole.log(\"max: \", max);\\n\\nvar maxProFit2 = (prices) => {\\n  let lowerPrice = prices[0];\\n  let profit = 0;\\n  for (let i = 0; i < prices.length; i++) {\\n    lowerPrice = Math.min(lowerPrice, prices[i]);\\n    profit = Math.max(profit, prices[i] - lowerPrice);\\n  }\\n  return profit;\\n};\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 股票2-可以多次买卖\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var maxProFit3 = (prices) => {\\n  let len = prices.length;\\n  if (!prices.length || prices.length < 2) return 0;\\n  // let dp = new Array(len).fill([0,0])\\n  let dp = Array.from(Array(len), () => Array(2).fill(0));\\n  dp[0][0] = -prices[0];\\n  dp[0][1] = 0;\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\\n  }\\n  return dp[len - 1][1];\\n};\\nconst max3 = maxProFit3([1, 2, 8, 2, 6, 3, 9]);\\nconsole.log(\"max3: \", max3);\\n\\nvar maxProFit3_2 = (prices) => {\\n  let len = prices.length,\\n    have = -prices[0],\\n    notHave = 0;\\n  for (let i = 1; i < len; i++) {\\n    have = Math.max(have, notHave - prices[i]);\\n    notHave = Math.max(notHave, have + prices[i]);\\n  }\\n  return notHave;\\n};\\nconst max3_2 = maxProFit3_2([1, 2, 8, 2, 6]);\\nconsole.log(\"max3_2: \", max3_2);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 股票3 ---最多买卖两次\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var maxProFit4 = (prices) => {\\n  let len = prices.length,\\n    dp = new Array(len).fill().map((x) => Array(5).fill(0));\\n  dp[0][0] = 0;\\n  dp[0][1] = -prices[0];\\n  dp[0][3] = -prices[0];\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = dp[i - 1][0];\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\\n    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\\n    dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\\n    dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\\n  }\\n  return dp[len - 1][4];\\n};\\nconst max4 = maxProFit4([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\\nconsole.log(\"max4: \", max4);\\n\\nconst maxProfit4_2 = (prices) => {\\n  const len = prices.length;\\n  const dp = new Array(len).fill(0);\\n  dp[1] = -prices[0];\\n  dp[3] = -prices[0];\\n  for (let i = 1; i < len; i++) {\\n    dp[1] = Math.max(dp[1], dp[0] - prices[i]);\\n    dp[2] = Math.max(dp[2], dp[1] + prices[i]);\\n    dp[3] = Math.max(dp[3], dp[2] - prices[i]);\\n    dp[4] = Math.max(dp[4], dp[3] + prices[i]);\\n  }\\n  return dp[4];\\n};\\n\\nconst max4_2 = maxProfit4_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\\nconsole.log(\"max4_2: \", max4_2);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 股票--含有冷冻期\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'const maxProfit5 = (prices) => {\\n  const len = prices.length;\\n  if (len < 2) {\\n    return 0;\\n  } else if (len < 3) {\\n    return Math.max(0, prices[1] - prices[0]);\\n  }\\n  const dp = Array.from(Array(len), () => Array(4).fill(0));\\n  dp[0][0] = 0 - prices[0];\\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\\n  // 2:今天卖出股票\\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\\n  for (let i = 1; i < len; i++) {\\n    dp[i][0] = Math.max(\\n      dp[i - 1][0],\\n      Math.max(dp[i - 1][1], dp[i - 1][3]) - prices[i]\\n    );\\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);\\n    dp[i][2] = dp[i - 1][0] + prices[i];\\n    dp[i][3] = dp[i - 1][2];\\n  }\\n  return Math.max(dp[len - 1][1], dp[len - 1][2], dp[len - 1][3]);\\n};\\n\\nconst max5 = maxProfit5([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\\nconsole.log(\"max5: \", max5);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 股票--含有冷冻期_2\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'const maxProfit5_2 = (prices) => {\\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\\n  // 2:今天卖出股票\\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\\n  const len = prices.length;\\n  const dp = new Array(len).fill(0);\\n  for (let i = 1; i < len; i++) {\\n    const temp1 = dp[0];\\n    const temp2 = dp[2];\\n    dp[0] = Math.max(dp[0], Math.max(dp[1], dp[3]) - prices[i]);\\n    dp[1] = Math.max(dp[1], dp[3]);\\n    dp[2] = temp1 + prices[i];\\n    dp[3] = temp2;\\n  }\\n  return Math.max(...dp);\\n};\\n\\nconst max5_2 = maxProfit5_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\\nconsole.log(\"max5_2: \", max5_2);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"给定一个含有 n 个正整数的数组和一个正整数 target 。\"),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"找出该数组中满足其总和大于等于 target 的长度最小的 连续\\n子数组\\n子数组\\n子数组 是数组中连续的 非空 元素序列。\"\n        ),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0\\n*/\\n//  长度最小的子数组\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var minSubArrayLen = function (target, nums) {\\n  let left = (right = 0),\\n    len = nums.length,\\n    sum = 0,\\n    res = len + 1;\\n  while (right < len) {\\n    sum += nums[right];\\n    while (sum >= target) {\\n      res = Math.min(res, right - left + 1);\\n      sum -= nums[left++];\\n    }\\n    right++;\\n  }\\n  return res > len ? 0 : res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"ol\", { attrs: { start: \"59\" } }, [\n            _c(\"li\", [\n              _vm._v(\n                \"螺旋矩阵 II (https://leetcode.cn/problems/spiral-matrix-ii/description/)\"\n              ),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _vm._v(\n            \"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\"\n          ),\n        ]),\n        _c(\"li\"),\n      ]),\n      _c(\"p\", [_vm._v(\"*/\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var generateMatrix = function (n) {\\n  let starX = (startY = 0),\\n    offset = 1,\\n    loop = Math.floor(n / 2),\\n    mid = Math.floor(n / 2),\\n    count = 1;\\n  let res = Array(n)\\n    .fill(0)\\n    .map(() => Array(n).fill(0));\\n\\n  while (loop--) {\\n    let row = starX,\\n      col = startY;\\n    // 上行从左到右\\n    for (; col < n - offset; col++) {\\n      res[row][col] = count++;\\n    }\\n    // 右列从上到下\\n    for (; row < n - offset; row++) {\\n      res[row][col] = count++;\\n    }\\n    // 下行从右到左\\n    for (; col > startY; col--) {\\n      res[row][col] = count++;\\n    }\\n    // 左列从下到上\\n    for (; row > starX; row--) {\\n      res[row][col] = count++;\\n    }\\n    starX++;\\n    startY++;\\n    offset++;\\n  }\\n  if (n % 2 === 1) {\\n    res[mid][mid] = count;\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 链表\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"class ListNode {\\n  constructor(value, next) {\\n    this.val = value;\\n    this.next = next;\\n  }\\n}\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 删除列表\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var removeElements = function (head, val) {\\n  const dummyHead = new ListNode(0, head);\\n  let cur = dummyHead;\\n  while (cur.next) {\\n    if (cur.next.val === val) {\\n      cur.next = cur.next.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n  }\\n  return dummyHead.next;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 设计链表\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var ListNode = function (val, next) {\\n  this.val = val === undefined ? 0 : val;\\n  this.next = next === undefined ? null : next;\\n};\\n\\nvar MyLinkedList = function () {\\n  this.size = 0;\\n  this.head = new ListNode(0);\\n};\\n\\n/**\\n * @param {number} index\\n * @return {number}\\n */\\nMyLinkedList.prototype.getNode = function (index) {\\n  if (index < 0 || index >= this.size) return -1;\\n  let cur = this.head;\\n  while (index-- >= 0) {\\n    cur = cur.next;\\n  }\\n  return cur.val;\\n};\\n\\nMyLinkedList.prototype.get = function (index) {\\n  return this.getNode(index);\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtHead = function (val) {\\n  this.addAtIndex(0, val);\\n};\\n\\n/**\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtTail = function (val) {\\n  this.addAtIndex(this.size, val);\\n};\\n\\n/**\\n * @param {number} index\\n * @param {number} val\\n * @return {void}\\n */\\nMyLinkedList.prototype.addAtIndex = function (index, val) {\\n  if (index > this.size) return;\\n  index = Math.max(0, index);\\n  this.size++;\\n  let cur = this.head;\\n  while (index--) {\\n    cur = cur.next;\\n  }\\n  let toAdd = new ListNode(val);\\n  toAdd.next = cur.next;\\n  cur.next = toAdd;\\n};\\n\\n/**\\n * @param {number} index\\n * @return {void}\\n */\\nMyLinkedList.prototype.deleteAtIndex = function (index) {\\n  if (index < 0 || index >= this.size) return;\\n  this.size--;\\n  let cur = this.head;\\n  while (index--) {\\n    cur = cur.next;\\n  }\\n  cur.next = cur.next.next;\\n};\\n\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"翻转链表\")]),\n        _c(\"li\", [_vm._v(\"@param {*} head\")]),\n        _c(\"li\", [_vm._v(\"@returns\\n*/\\n//\\n// 双指针\")]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var reverseList = function (head) {\\n  if (!head || !head.next) return head;\\n  let pre = null,\\n    cur = head,\\n    temp = null;\\n  while (cur) {\\n    temp = cur.next;\\n    cur.next = pre;\\n    pre = cur;\\n    cur = temp;\\n  }\\n  return pre;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 翻转链表-递归1\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var reverse = function (pre, head) {\\n  if (!head) return pre;\\n  let temp = head.next;\\n  head.next = pre;\\n  pre = head;\\n  reverse(pre, temp);\\n};\\nvar reverseList = function (head) {\\n  reverse(null, head);\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 24. 两两交换链表中的节点\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var swapPairs = function (head) {\\n  let ret = new ListNode(0, head),\\n    temp = ret;\\n  while (temp.next && temp.next.next) {\\n    let cur = temp.next.next,\\n      pre = temp.next;\\n    pre.next = cur.next;\\n    cur.next = pre;\\n    temp.next = cur;\\n    temp = pre;\\n  }\\n  return ret.next;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 19. 删除链表的倒数第 N 个结点\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var removeNthFromEnd = function (head, n) {\\n  let ret = new ListNode(0, head),\\n    slow = (fast = ret);\\n  while (n--) {\\n    fast = fast.next;\\n  }\\n  while (fast.next !== null) {\\n    fast = fast.next;\\n    slow = slow.next;\\n  }\\n  slow.next = slow.next.next;\\n  return ret.next;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 142. 环形链表 II (给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。)\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var detectCycle = function (head) {\\n  if (!head || !head.next) return null;\\n  let slow = (fast = head);\\n  while (fast && fast.next && fast.next.next) {\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    if (fast === slow) {\\n      slow = head;\\n      while (fast !== slow) {\\n        fast = fast.next;\\n        slow = slow.next;\\n      }\\n      return slow;\\n    }\\n  }\\n  return null;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 02.07. 链表相交 1\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var getIntersectionNode1 = function (headA, headB) {\\n  if (!headA || !headB) return null;\\n  let curA = headA,\\n    curB = headB;\\n  while (curA !== curB) {\\n    curA = curA ? curA.next : headB;\\n    curB = curB ? curB.next : headA;\\n  }\\n  return curA;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 02.07. 链表相交 2\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var getIntersectionNode2 = function (headA, headB) {\\n  if (!headA || !headB) return null;\\n  const visited = new Set();\\n  let temp = headA;\\n  while (temp) {\\n    visited.add(temp);\\n    temp = temp.next;\\n  }\\n  temp = headB;\\n  while (temp) {\\n    if (visited.has(temp)) return temp;\\n    temp = temp.next;\\n  }\\n  return null;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\\n// 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var isAnagram = function (s, t) {\\n  if (s.length !== t.length) return false;\\n  let ret = new Array(26).fill(0),\\n    base = \"a\".charCodeAt();\\n  for (const i of s) {\\n    ret[i.charCodeAt() - base]++;\\n  }\\n  for (const i of t) {\\n    if (!ret[i.charCodeAt() - base]) return false;\\n    ret[i.charCodeAt() - base]--;\\n  }\\n  return true;\\n};\\nvar isAnagram2 = function (s, t) {\\n  if (s.length !== t.length) return false;\\n  let ret = new Map();\\n  for (const i of s) {\\n    ret.set(i, (ret.get(i) || 0) + 1);\\n  }\\n  for (const i of t) {\\n    if (!ret.get(i)) return false;\\n    ret.set(i, ret.get(i) - 1);\\n  }\\n  return true;\\n};\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的 交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\\n// https://leetcode.cn/problems/intersection-of-two-arrays/\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var intersection = function (nums1, nums2) {\\n  if (nums1.length < nums2.length) {\\n    [nums2, nums1] = [nums1, nums2];\\n  }\\n  let ret1 = new Set(nums1),\\n    ret2 = new Set();\\n  for (let i = 0; i < nums2.length; i++) {\\n    ret1.has(nums2[i]) && ret2.add(nums2[i]);\\n  }\\n  return Array.from(ret2);\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 202. 快乐数\\n//「快乐数」 定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\\n// 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\\n// 如果这个过程 结果为 1，那么这个数就是快乐数。\\n// 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var isHappy = function (n) {\\n  let m = new Set();\\n  let getSum = (num) => {\\n    let sum = 0;\\n    while (num) {\\n      sum += (num % 10) ** 2;\\n      num = Math.floor(num / 10);\\n    }\\n  };\\n  // 1\\n  // while(true) {\\n  //   if (m.has(n)) return false\\n  //   if (n === 1) return true\\n  //   n = getSum(n)\\n  //   m.add(n)\\n  // }\\n  // 2\\n  while (n !== 1 && !m.has(n)) {\\n    m.add(n);\\n    n = getSum(n);\\n  }\\n  return n === 1;\\n};\\nisHappy(19);\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 1. 两数之和\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var twoSum = function (nums, target) {\\n  let has = {};\\n  for (let i = 0; i < nums.length; i++) {\\n    if (has[target - nums[i]] !== undefined) {\\n      return [i, has[target - nums[i]]];\\n    }\\n    has[nums[i]] = i;\\n  }\\n  return [];\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var fourSumCount = function (nums1, nums2, nums3, nums4) {\\n  let map = new Map();\\n  nums1.forEach((n1) =>\\n    nums2.forEach((n2) => map.set(n1 + n2, (map.get(n1 + n2) || 0) + 1))\\n  );\\n  let count = 0;\\n  for (let n3 of nums3) {\\n    for (let n4 of nums4) {\\n      if (map.has(-(n3 + n4))) {\\n        count += map.get(-(n3 + n4));\\n      }\\n    }\\n  }\\n  return count;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 383. 赎金信 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var canConstruct = function (ransomNote, magazine) {\\n  let strArr = Array(26).fill(0),\\n    base = \"a\".charCodeAt();\\n  for (let i of magazine) {\\n    strArr[i.charCodeAt() - base]++;\\n  }\\n  for (let u of ransomNote) {\\n    let index = u.charCodeAt() - base;\\n    if (!strArr[index]) return false;\\n    strArr[index]--;\\n  }\\n  return true;\\n};\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\\n// 你返回所有和为 0 且不重复的三元组。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var threeSum = function (nums) {\\n  let res = [],\\n    len = nums.length;\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < len; i++) {\\n    let l = i + 1,\\n      r = len - 1,\\n      iNum = nums[i];\\n    if (iNum > 0) return res;\\n    if (iNum === nums[i - 1]) continue;\\n    while (l < r) {\\n      let lNum = nums[l],\\n        rNum = nums[r],\\n        threeSum = iNum + lNum + rNum;\\n      if (threeSum < 0) l++;\\n      else if (threeSum > 0) r--;\\n      else {\\n        res.push([iNum, lNum, rNum]);\\n        while (l < r && nums[l] === nums[l + 1]) {\\n          l++;\\n        }\\n        while (l < r && nums[r] === nums[r - 1]) {\\n          r--;\\n        }\\n        l++;\\n        r--;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var fourSum = function (nums, target) {\\n  let res = [],\\n    len = nums.length;\\n  if (len < 4) return [];\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < len - 3; i++) {\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n\\n    for (let j = i + 1; j < len - 2; j++) {\\n      if (j > i + 1 && nums[j] === nums[j - 1]) continue;\\n\\n      let l = j + 1,\\n        r = len - 1;\\n      while (l < r) {\\n        const sum = nums[i] + nums[j] + nums[l] + nums[r];\\n        if (sum > target) r--;\\n        else if (sum < target) l++;\\n        else {\\n          res.push([nums[i], nums[j], nums[l], nums[r]]);\\n          // while (l < r && nums[l] === nums[l + 1]) {\\n          //   l++\\n          // }\\n          // while (l < r && nums[r] === nums[r - 1]) {\\n          //   r--;\\n          // }\\n          // l++\\n          // r--\\n          while (l < r && nums[l] === nums[++l]);\\n          while (l < r && nums[r] === nums[--r]);\\n        }\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 344. 反转字符串\\n// 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var reverseString = function (s) {\\n  // let l = -1,r = s.length;\\n  // while(++l < --r) [s[l], s[r]] = [s[r], s[l]]\\n  let l = 0,\\n    r = s.length - 1,\\n    temp = null;\\n  while (l < r) {\\n    temp = s[l];\\n    s[l] = s[r];\\n    s[r] = temp;\\n    l++;\\n    r--;\\n  }\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 541. 反转字符串 II\\n// 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var reverseStr = function (s, k) {\\n  let len = s.length,\\n    resArr = s.split(\"\");\\n  // for (let i = 0; i < len; i += 2 * k) {\\n  //   let l = i - 1,\\n  //     r = i + k > len ? len : i + k;\\n  //   while (++l < --r) [[resArr[l]], resArr[r]] = [[resArr[r]], resArr[l]];\\n  // }\\n  for (let i = 0; i < len; i += 2 * k) {\\n    let l = i - 1,\\n      r = i + k > len ? len : i + k,\\n      temp = null;\\n    while (++l < --r) {\\n      temp = resArr[l];\\n      resArr[l] = resArr[r];\\n      resArr[r] = temp;\\n    }\\n  }\\n  return resArr.join(\"\");\\n};\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          '// 替换数字（第八期模拟笔试）\\n// 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 \"a1b2c3\"，函数应该将其转换为 \"anumberbnumbercnumber\"。'\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'let numberToStringFn = function (str) {\\n  let num0 = \"0\".charCodeAt(),\\n    num9 = \"9\".charCodeAt(),\\n    a = \"a\".charCodeAt(),\\n    z = \"z\".charCodeAt(),\\n    len = str.length,\\n    n = 0;\\n  let isNumber = (code) => {\\n    code = code.charCodeAt();\\n    return code >= num0 && code <= num9;\\n  };\\n  let isAz = (code) => {\\n    code = code.charCodeAt();\\n    return code >= a && code <= z;\\n  };\\n  // 计算新数组长度\\n  for (let i = 0; i < len; i++) {\\n    if (isNumber(str[i])) {\\n      n += 6;\\n    } else if (isAz(str[i])) {\\n      n += 1;\\n    } else {\\n      n += 1;\\n    }\\n  }\\n  let newArr = Array(n).fill(\"\"),\\n    index = n - 1;\\n  for (let i = len - 1; i >= 0; i--) {\\n    if (isAz(str[i])) {\\n      // 字符串\\n      newArr[index] = str[i];\\n      index--;\\n    } else if (isNumber(str[i])) {\\n      // number\\n      newArr[index] = \"r\";\\n      newArr[index - 1] = \"e\";\\n      newArr[index - 2] = \"b\";\\n      newArr[index - 3] = \"m\";\\n      newArr[index - 4] = \"u\";\\n      newArr[index - 5] = \"n\";\\n      index -= 6;\\n    }\\n  }\\n  console.log(newArr.join(\"\"));\\n  console.log(newArr.join(\"\").length);\\n};\\n\\nnumberToStringFn(\"12jsd3k2n5k6k9\");\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 151. 反转字符串中的单词\\n/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\\n*/\"\n          ),\n        ]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var reverseWords = function (s) {\\n  // function removeExtraSpaces(strArr) {\\n  //   let slowIndex = 0, fastIndex = 0;\\n  //   while(fastIndex < strArr.length) {\\n  //     if (strArr[fastIndex] === ' ' && (fastIndex === 0 || strArr[fastIndex - 1] === ' ')) {\\n  //       fastIndex++\\n  //     } else {\\n  //       strArr[slowIndex++] = strArr[fastIndex++]\\n  //     }\\n  //   }\\n  //   strArr.length = strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex\\n  // }\\n  // function reverse(strArr, start, end) {\\n  //   let l = start,r = end;\\n  //   while(l < r) {\\n  //     [strArr[r], strArr[l]] = [strArr[l], strArr[r]]\\n  //     l++\\n  //     r--\\n  //   }\\n  // }\\n\\n  // const strArr = Array.from(s)\\n  // removeExtraSpaces(strArr)\\n  // // 翻转\\n  // reverse(strArr, 0, strArr.length - 1)\\n  // let start = 0\\n  // for(let i = 0; i <= strArr.length;i++) {\\n  //   if (strArr[i] === ' ' || i === strArr.length) {\\n  //     reverse(strArr, start, i - 1)\\n  //     start = i + 1\\n  //   }\\n  // }\\n  // return strArr.join('')\\n\\n  // 2--------\\n  const strArr = s.trim().split(/\\\\s+/);\\n  let i = 0,\\n    j = strArr.length - 1;\\n  for (; i <= j; i++, j--) {\\n    // 1----------\\n    // [strArr[j], strArr[i]] = [strArr[i], strArr[j]];\\n\\n    // 2----------\\n    let tmp = sArr[i];\\n    sArr[i] = sArr[j];\\n    sArr[j] = tmp;\\n  }\\n  return strArr.join(\\\" \\\");\\n};\\nreverseWords(\\\"asdf sd adf sd fe\\\");\\n\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 右旋字符串\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'function reverseStrFn(arr, start, end) {\\n  let l = start,\\n    r = end;\\n  while (l < r) {\\n    [arr[r], arr[l]] = [arr[l], arr[r]];\\n    l++;\\n    r--;\\n  }\\n  return arr;\\n}\\n\\nfunction reVerArr(arr, n) {\\n  reverseStrFn(arr, 0, arr.length - 1);\\n  reverseStrFn(arr, 0, n - 1);\\n  reverseStrFn(arr, n, arr.length - 1);\\n  console.log(\"arr: \", arr.join(\"\"));\\n  return arr.join(\"\");\\n}\\nlet arr = Array.from(\"asbejkl\");\\nreVerArr(arr, 3);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 28. 找出字符串中第一个匹配项的下标\\n/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。\"\n          ),\n        ]),\n        _c(\"li\", [_vm._v(\"@param {*} haystack\")]),\n        _c(\"li\", [_vm._v(\"@param {*} needle\\n*/\")]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var strStr = function (haystack, needle) {\\n if (!needle.length) return 0;\\n var getNext = (needle) => {\\n   let j = 0,\\n     next = [];\\n   next[0] = 0;\\n   for (let i = 1; i < needle.length; i++) {\\n     while (j > 0 && needle[i] !== needle[j]) {\\n       console.log(\"j: \", j);\\n       j = next[j - 1];\\n     }\\n     if (needle[i] === needle[j]) {\\n       j++;\\n     }\\n     next[i] = j;\\n   }\\n   return next;\\n };\\n let next = getNext(needle);\\n let j = 0;\\n for (let i = 0; i < haystack.length; i++) {\\n   while (j > 0 && haystack[i] !== needle[j]) {\\n     j = next[j - 1];\\n   }\\n   if (haystack[i] === needle[j]) {\\n     j++;\\n   }\\n   if (j === needle.length) {\\n     return i + 1 - needle.length;\\n   }\\n }\\n return -1;\\n};\\n\\nconst f = strStr(\"6sadbutsad\", \"sad\");\\nconsole.log(\"f: \", f);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 459.重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var repeatedSubstringPattern = function (s) {\\n  let len = s.length;\\n  if (!len) return false;\\n  let getNext = (s) => {\\n    let j = 0,\\n      next = [0];\\n    for (let i = 1; i < s.length; i++) {\\n      while (j > 0 && s[i] !== s[j]) {\\n        j = next[j - 1];\\n      }\\n      if (s[i] === s[j]) {\\n        j++;\\n      }\\n      next.push(j);\\n    }\\n    return next;\\n  };\\n  let next = getNext(s),\\n    len2 = next.length;\\n  return next[len2 - 1] !== 0 && len % (len - next[len2 - 1]) === 0;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var removeElement = function (nums, val) {\\n  // let k = 0\\n  // for(let i = 0; i < nums.length; i++) {\\n  //   if (nums[i] !== val) {\\n  //     nums[k++] = nums[i]\\n  //   }\\n  // }\\n  // // nums.length = k\\n  // return k\\n  let l = 0,\\n    r = nums.length;\\n  while (l < r) {\\n    if (nums[l] === val) {\\n      nums[l] = nums[--r];\\n    } else {\\n      l++;\\n    }\\n  }\\n  nums.length = l;\\n  console.log(\"nums: \", nums);\\n  return l;\\n};\\nremoveElement([1, 2, 3, 3, 5, 5], 5);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var MyQueueFn = () => {\\n  var MyQueue = function () {\\n    this.stackIn = [];\\n    this.stackOut = [];\\n  };\\n\\n  /**\\n   * @param {number} x\\n   * @return {void}\\n   */\\n  MyQueue.prototype.push = function (x) {\\n    this.stackIn.push(x);\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyQueue.prototype.pop = function () {\\n    const size = this.stackOut.length;\\n    if (size) {\\n      return this.stackOut.pop();\\n    }\\n    while (this.stackIn.length) {\\n      this.stackOut.push(this.stackIn.pop());\\n    }\\n    return this.stackOut.pop();\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyQueue.prototype.peek = function () {\\n    const x = this.pop();\\n    this.stackOut.push(x);\\n    return x;\\n  };\\n\\n  /**\\n   * @return {boolean}\\n   */\\n  MyQueue.prototype.empty = function () {\\n    return !this.stackIn.length && !this.stackOut.length;\\n  };\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 225. 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var MyStackFn = () => {\\n  var MyStack = function () {\\n    this.queue1 = [];\\n    this.queue2 = [];\\n  };\\n  /**\\n   * @param {number} x\\n   * @return {void}\\n   */\\n  MyStack.prototype.push = function (x) {\\n    this.queue1.push(x);\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyStack.prototype.pop = function () {\\n    if (!this.queue1.length) {\\n      [this.queue2, this.queue1] = [this.queue1, this.queue2];\\n    }\\n    while (this.queue1.length > 1) {\\n      this.queue2.push(this.queue1.shift());\\n    }\\n    return this.queue1.shift();\\n  };\\n\\n  /**\\n   * @return {number}\\n   */\\n  MyStack.prototype.top = function () {\\n    var x = this.pop();\\n    this.queue1.push(x);\\n    return x;\\n  };\\n\\n  /**\\n   * @return {boolean}\\n   */\\n  MyStack.prototype.empty = function () {\\n    return !this.queue1.length && !this.queue2.length;\\n  };\\n};\\n\\n// 用一个队列实现-------\\nclass MyStack {\\n  constructor() {\\n    this.queue = [];\\n  }\\n\\n  push(x) {\\n    this.queue.push(x);\\n  }\\n\\n  pop() {\\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\\n    let size = this.queue.length;\\n    while (size-- > 1) {\\n      this.queue.push(this.queue.shift());\\n    }\\n    // 移除并返回最后一个元素\\n    return this.queue.shift();\\n  }\\n  top() {\\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\\n    const x = this.pop();\\n    this.queue.push(x);\\n  }\\n  empty() {\\n    return this.queue.length === 0;\\n  }\\n}\\n\\n// 示例用法：\\nconst stack = new MyStack();\\nstack.push(1);\\nstack.push(2);\\nconsole.log(stack.top()); // 输出 2\\nconsole.log(stack.pop()); // 输出 2\\nconsole.log(stack.empty()); // 输出 false\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"有效字符串需满足：\\n左括号必须用相同类型的右括号闭合。\\n左括号必须以正确的顺序闭合。\\n每个右括号都有一个对应的相同类型的左括号。\\n*/\\n// 20. 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效\"\n          ),\n        ]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var isValid = function (s) {\\n  // let list = [];\\n  // for(let i of s) {\\n  //   switch (i) {\\n  //     case \\'(\\':\\n  //       list.push(\\')\\')\\n  //       break;\\n  //     case \\'[\\':\\n  //       list.push(\\']\\')\\n  //       break;\\n  //     case \\'{\\':\\n  //       list.push(\\'}\\')\\n  //       break;\\n  //     default:\\n  //       if (i !== list.pop()) return false\\n  //       break;\\n  //   }\\n  // }\\n  // return !list.length\\n  let list = [],\\n    map = {\\n      \"(\": \")\",\\n      \"[\": \"]\",\\n      \"{\": \"}\",\\n    };\\n  for (let i of s) {\\n    if (map[i]) {\\n      list.push(i);\\n      continue;\\n    }\\n    if (map[list.pop()] !== i) return false;\\n  }\\n  return !list.length;\\n};\\nisValid(\"((\");\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 1047. 删除字符串中的所有相邻重复项\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var removeDuplicates = function (s) {\\n  // var list = []\\n  // for(let i of s) {\\n  //   let lastVal = list.length ? list[list.length - 1] : null\\n  //   if (i === lastVal) {\\n  //     list.pop()\\n  //   } else {\\n  //     list.push(i)\\n  //   }\\n  // }\\n  // return list.join(\\'\\')\\n  let list = [...s],\\n    top = -1;\\n  for (let i of s) {\\n    if (top === -1 || list[top] !== i) {\\n      list[++top] = i;\\n    } else {\\n      top--;\\n    }\\n  }\\n  list.length = top + 1;\\n  console.log(\"list.join\", list.join(\"\"));\\n  return list.join(\"\");\\n};\\nremoveDuplicates(\"dbccab\");\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 150. 逆波兰表达式求值 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var evalRPN = function (tokens) {\\n  let stack = [];\\n  for (const token of tokens) {\\n    if (isNaN(Number(token))) {\\n      // 重点 isNaN()\\n      const n2 = stack.pop(); // 出栈两个数字\\n      const n1 = stack.pop();\\n      switch (token) {\\n        case \"+\":\\n          stack.push(n1 + n2);\\n          break;\\n        case \"-\":\\n          stack.push(n1 - n2);\\n          break;\\n        case \"*\":\\n          stack.push(n1 * n2);\\n          break;\\n        case \"/\":\\n          const st = (n1 / n2) | 0; // 重点 | 0\\n          stack.push(st);\\n          break;\\n      }\\n    } else {\\n      stack.push(Number(token));\\n    }\\n  }\\n  console.log(\"stack[0]: \", stack[0]);\\n  return stack[0];\\n};\\n\\nevalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]);\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。\"\n        ),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"@param {number[]} nums\")]),\n        _c(\"li\", [_vm._v(\"@param {number} k\")]),\n        _c(\"li\", [_vm._v(\"@return {number[]}\\n*/\")]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var maxSlidingWindow = function (nums, k) {\\n class MonoQueue {\\n   queue;\\n   constructor() {\\n     this.queue = [];\\n   }\\n   enqueue(value) {\\n     let back = this.queue[this.queue.length - 1];\\n     while (back !== undefined && back < value) {\\n       this.queue.pop();\\n       back = this.queue[this.queue.length - 1];\\n     }\\n     this.queue.push(value);\\n   }\\n   dequeue(value) {\\n     const front = this.front();\\n     if (front === value) {\\n       this.queue.shift();\\n     }\\n   }\\n   front() {\\n     return this.queue[0];\\n   }\\n }\\n const helpQueue = new MonoQueue();\\n let i = 0,\\n   j = 0,\\n   resArr = [];\\n // 先将前k个参数循环一遍\\n while (j < k) {\\n   helpQueue.enqueue(nums[j++]);\\n }\\n resArr.push(helpQueue.front());\\n // 再让i从0开始 如果有一样的走过的参数从列表里面删除掉\\n while (j < nums.length) {\\n   helpQueue.enqueue(nums[j++]);\\n   helpQueue.dequeue(nums[i++]);\\n   resArr.push(helpQueue.front());\\n }\\n return resArr;\\n};\\nmaxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\\n*\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"在 JavaScript 中，小顶堆通常使用数组来实现。数组表示小顶堆时，元素按层级顺序存储，\"\n          ),\n        ]),\n        _c(\"li\", [_vm._v(\"即父节点的索引为 i，其左子节点的索引为 2*i + 1，\")]),\n        _c(\"li\", [\n          _vm._v(\n            \"右子节点的索引为 2*i + 2。这种存储方式使得堆的操作非常高效。\"\n          ),\n        ]),\n        _c(\"li\"),\n        _c(\"li\", [\n          _vm._v(\n            \"数组表示的具体规则\\n根节点：根节点在数组中的索引为 0。\\n左子节点：对于索引为 i 的节点，左子节点的索引为 2\"\n          ),\n          _c(\"em\", [\n            _vm._v(\n              \"i + 1。\\n右子节点：对于索引为 i 的节点，右子节点的索引为 2\"\n            ),\n          ]),\n          _vm._v(\n            \"i + 2。\\n父节点：对于索引为 i 的节点，父节点的索引为 Math.floor((i - 1) / 2)。\"\n          ),\n        ]),\n        _c(\"li\"),\n      ]),\n      _c(\"p\", [_vm._v(\"*/\")]),\n      _c(\"p\", [_vm._v(\"// js实现小顶堆\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"class MinHeap {\\n  constructor(compareFn) {\\n    this.head = [];\\n    this.compareFn = compareFn;\\n  }\\n  getParentIndex(index) {\\n    return Math.floor((index - 1) / 2);\\n  }\\n  getLeftChildIndex(index) {\\n    return index * 2 + 1;\\n  }\\n  getRightChildIndex(index) {\\n    return index * 2 + 2;\\n  }\\n  swap(index1, index2) {\\n    [this.head[index2], this.head[index1]] = [\\n      this.head[index1],\\n      this.head[index2],\\n    ];\\n  }\\n  compare(index1, index2) {\\n    if (this.head[index1] === undefined) return 1;\\n    if (this.head[index2] === undefined) return -1;\\n    return this.compareFn(this.head[index1], this.head[index2]);\\n  }\\n  insert(val) {\\n    this.head.push(val);\\n    this.headPiFyUp();\\n  }\\n  // 向上堆积\\n  headPiFyUp() {\\n    let index = this.head.length - 1;\\n    while (index > 0) {\\n      let parentIndex = this.getParentIndex(index);\\n      //  this.head[index] < this.head[parentIndex]\\n      if (this.compare(index, parentIndex) < 0) {\\n        this.swap(index, parentIndex);\\n        index = parentIndex;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  remove() {\\n    let len = this.head.length;\\n    if (!len) return null;\\n    if (len === 1) return this.head.pop();\\n    const root = this.head[0];\\n    this.head[0] = this.head.pop();\\n    this.headPiFyDown(0);\\n    return root;\\n  }\\n  // 向下堆积\\n  headPiFyDown(index) {\\n    let smallest = index;\\n    const leftChildrenIndex = this.getLeftChildIndex(index);\\n    const rightChildrenIndex = this.getRightChildIndex(index);\\n    // if (leftChildrenIndex < this.head.length && this.head[leftChildrenIndex] < this.head[smallest]) {\\n    if (\\n      leftChildrenIndex < this.head.length &&\\n      this.compare(leftChildrenIndex, smallest) < 0\\n    ) {\\n      smallest = leftChildrenIndex;\\n    }\\n    // if (rightChildrenIndex < this.head.length && this.head[rightChildrenIndex] < this.head[smallest]) {\\n    if (\\n      rightChildrenIndex < this.head.length &&\\n      this.compare(rightChildrenIndex, smallest) < 0\\n    ) {\\n      smallest = rightChildrenIndex;\\n    }\\n    if (smallest !== index) {\\n      // 说明进行了转换\\n      this.swap(index, smallest);\\n      this.headPiFyDown(smallest);\\n    }\\n  }\\n  getMin() {\\n    return this.head[0];\\n  }\\n  size() {\\n    return this.head.length;\\n  }\\n  isEmpty() {\\n    return !this.head.length;\\n  }\\n  buildHeap(arr) {\\n    this.head = arr;\\n    for (let i = Math.floor(this.head.length / 2) - 1; i >= 0; i--) {\\n      this.headPiFyDown(i);\\n    }\\n  }\\n  printHeap() {\\n    console.log(this.head);\\n  }\\n}\\n\\n// const testMinHeap = () => {\\n//   const minHeap = new MinHeap((a, b) => a - b)\\n//   minHeap.insert(10)\\n//   minHeap.insert(1)\\n//   minHeap.insert(2)\\n//   minHeap.insert(3)\\n//   minHeap.insert(4)\\n//   minHeap.printHeap()\\n\\n//   const minVal1 = minHeap.getMin()\\n//   console.log('minVal1: ', minVal1);\\n\\n//   minHeap.remove()\\n//   minHeap.printHeap()\\n\\n//   const minVal2 = minHeap.getMin()\\n//   console.log('minVal2: ', minVal2);\\n\\n//   minHeap.insert(5)\\n//   minHeap.printHeap()\\n\\n//   const minVal3 = minHeap.getMin()\\n//   console.log('minVal3: ', minVal3);\\n// }\\n// testMinHeap()\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 347. 前 K 个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'var topKFrequent = function (nums, k) {\\n  const map = new Map();\\n  for (const i of nums) {\\n    map.set(i, (map.get(i) || 0) + 1);\\n  }\\n\\n  const heap = new MinHeap((a, b) => a[1] - b[1]);\\n\\n  for (const i of map.entries()) {\\n    heap.insert(i);\\n    if (heap.size() > k) {\\n      heap.remove();\\n    }\\n  }\\n  const res = [];\\n  heap.printHeap();\\n  for (let i = heap.size() - 1; i >= 0; i--) {\\n    res.push(heap.remove()[0]);\\n  }\\n  console.log(\"res: \", res);\\n  return res;\\n};\\n\\ntopKFrequent([1, 1, 1, 2, 2, 3], 2);\\n\\nconst topKFrequent2 = (nums, k) => {\\n  const map = new Map();\\n  for (const i of nums) {\\n    map.set(i, (map.get(i) || 0) + 1);\\n  }\\n  //返回一个按出现次数降序的二维数组\\n  let sortArray = Array.from(map).sort((a, b) => b[1] - a[1]),\\n    res = [];\\n  for (let i = 0; i < k; i++) {\\n    res.push(sortArray[i][0]);\\n  }\\n  console.log(\"res: \", res);\\n  return res;\\n};\\ntopKFrequent2([1, 1, 1, 2, 2, 3], 2);\\n\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 二叉树节点类\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'class TreeNode {\\n  constructor(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n  }\\n}\\nclass BinaryTree {\\n  constructor() {\\n    this.root = null;\\n  }\\n  insert(value) {\\n    const newNode = new TreeNode(value);\\n    if (this.root === null) {\\n      this.root = newNode;\\n    } else {\\n      this.insertNode(this.root, newNode);\\n    }\\n  }\\n  insertNode(node, newNode) {\\n    if (newNode.value < node.value) {\\n      // 新节点放到left\\n      if (node.left === null) {\\n        node.left = newNode;\\n      } else {\\n        this.insertNode(node.left, newNode);\\n      }\\n    } else {\\n      // 新节点放到right\\n      if (node.right === null) {\\n        node.right = newNode;\\n      } else {\\n        this.insertNode(node.right, newNode);\\n      }\\n    }\\n  }\\n  search(value) {\\n    return this.searchNode(this.root, value);\\n  }\\n  searchNode(root, value) {\\n    if (root === null) return false;\\n    if (value < root.value) {\\n      this.searchNode(root.left, value);\\n    } else if (value > root.value) {\\n      this.searchNode(root.right, value);\\n    } else {\\n      return true;\\n    }\\n  }\\n  /**\\n   * \\n   * 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式\\n    前序遍历：中左右\\n    中序遍历：左中右\\n    后序遍历：左右中\\n   */\\n  // 前序遍历\\n  preOrder(node = this.root) {\\n    if (node !== null) {\\n      console.log(node.value);\\n      this.preOrder(node.left);\\n      this.preOrder(node.right);\\n    }\\n  }\\n  // 中序遍历\\n  inOrder(node = this.root) {\\n    if (node !== null) {\\n      this.preOrder(node.left);\\n      console.log(node.value);\\n      this.preOrder(node.right);\\n    }\\n  }\\n  // 后序遍历\\n  postOrder(node = this.root) {\\n    if (node !== null) {\\n      this.preOrder(node.left);\\n      this.preOrder(node.right);\\n      console.log(node.value);\\n    }\\n  }\\n}\\n\\nconst treeTestFn = () => {\\n  const tree = new BinaryTree();\\n  tree.insert(7);\\n  tree.insert(4);\\n  tree.insert(9);\\n  tree.insert(1);\\n  tree.insert(6);\\n  tree.insert(8);\\n  tree.insert(10);\\n\\n  console.log(\"中序遍历\");\\n  tree.inOrder();\\n\\n  console.log(\"前序遍历\");\\n  tree.preOrderOrder();\\n\\n  console.log(\"后序遍历\");\\n  tree.postOrder();\\n\\n  console.log(\"查找节点\");\\n  console.log(tree.search(6));\\n  console.log(tree.search(15));\\n};\\ntreeTestFn();\\n\\nconst binaryTreeTraversal2 = () => {\\n  // 迭代法遍历\\n  // ---前序遍历---: (中左右) 栈进入顺序 右 -> 左; 出栈  中 -> 左 -> 右\\n  const preOrderTraversal = (root) => {\\n    let res = [];\\n    if (!root) return res;\\n    let stack = [root],\\n      cur = null;\\n    while (stack.length) {\\n      cur = stack.pop();\\n      res.push(cur.val);\\n      cur.right && stack.push(cur.right);\\n      cur.left && stack.push(cur.left);\\n    }\\n    return res;\\n  };\\n  // ---前序遍历--- 中左右  压入栈右->左->中; 出栈 中->左->右\\n  // const preOrderTraversal = (root) => {\\n  //   let res = [],\\n  //     stack = [root];\\n  //   while (stack.length) {\\n  //     const node = stack.pop();\\n  //     if (!node) {\\n  //       res.push(stack.pop().val);\\n  //       continue;\\n  //     }\\n  //     node.right && stack.push(node.right); // 右\\n  //     node.left && stack.push(node.left); // 左\\n  //     stack.push(node); // 中\\n  //     stack.push(null);\\n  //   }\\n  //   return res;\\n  // };\\n\\n  // ---中序遍历---: (左中右) 入栈 左 -> 右;  出栈 左 -> 中 -> 右\\n  const inOrderTraversal = (root) => {\\n    if (!root) return [];\\n    let res = [],\\n      stack = [],\\n      cur = root;\\n    do {\\n      if (cur) {\\n        stack.push(cur);\\n        cur = cur.left;\\n      } else {\\n        cur = stack.pop();\\n        res.push(cur.val);\\n        cur = cur.right;\\n      }\\n    } while (stack.length || cur);\\n    return res;\\n  };\\n\\n  // ---后序遍历---: (左右中) 栈进入顺序 左 -> 右;  出栈  中 -> 右 -> 左 结果翻转\\n  const postOrderTraversal = (root) => {\\n    let res = [];\\n    if (!root) return res;\\n    let stack = [root],\\n      cur = null;\\n    while (stack.length) {\\n      cur = stack.pop();\\n      res.push(cur.val);\\n      cur.left && stack.push(cur.left);\\n      cur.right && stack.push(cur.right);\\n    }\\n    return res.reverse();\\n  };\\n  // ---后续遍历--- 左右中\\n  // const postOrderTraversal_2 = (root) => {\\n  //   let res = [];\\n  //   if (!root) return res;\\n  //   let stack = [root],\\n  //     visited = new Set();\\n\\n  //   while (stack.length) {\\n  //     const node = stack[stack.length - 1];\\n  //     if (node.left && !visited.has(node.left)) {\\n  //       stack.push(node.left);\\n  //     } else if (node.right && !visited.has(node.right)) {\\n  //       stack.push(node.right);\\n  //     } else {\\n  //       res.push(node.val);\\n  //       visited.add(node);\\n  //       stack.pop();\\n  //     }\\n  //   }\\n  //   return res;\\n  // };\\n};\\n\\n// 示例二叉树结构\\nclass TreeNode {\\n  constructor(val, left = null, right = null) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n  }\\n}\\n\\nconst root = new TreeNode(1);\\nroot.left = new TreeNode(2);\\nroot.right = new TreeNode(3);\\nroot.left.left = new TreeNode(4);\\nroot.left.right = new TreeNode(5);\\nroot.right.left = new TreeNode(6);\\nroot.right.right = new TreeNode(7);\\n\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 测试前序遍历方法\")]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 102.二叉树的层序遍历次  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const levelOrder = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let curLevel = [],\\n      len = queue.length;\\n    for (let i = 0; i < len; i++) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    // res.push(curLevel);\\n    res.unshift(curLevel);\\n  }\\n  return res;\\n};\\n// 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\\nconst levelOrderBottom = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let curLevel = [],\\n      len = queue.length;\\n    while (len--) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      // 把下一层级的左右节点存入queue队列\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.unshift(curLevel);\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 199.二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              'class TreeNode {\\n  constructor(val, left = null, right = null) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n  }\\n}\\n\\nconst root = new TreeNode(1);\\nroot.left = new TreeNode(2);\\nroot.right = new TreeNode(3);\\nroot.left.left = new TreeNode(4);\\nroot.left.right = new TreeNode(5);\\nroot.right.left = new TreeNode(6);\\nroot.right.right = new TreeNode(7);\\n\\nconst rightSideView = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length;\\n    while (len--) {\\n      const node = queue.shift();\\n      if (!len) {\\n        res.push(node.val);\\n      }\\n      // 把下一层级的左右节点存入queue队列\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n  }\\n  return res;\\n};\\nconsole.log(\"rightSideView(root): \", rightSideView(root));\\n'\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 637.二叉树的层平均值  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const averageOfLevels = (root) => {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let sum = 0,\\n      curLen = queue.length,\\n      len = curLen;\\n    while (len--) {\\n      const node = queue.shift();\\n      sum += node.val;\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.push(sum / curLen);\\n  }\\n  return res;\\n};\\n\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"ol\", [\n            _c(\"li\", [\n              _vm._v(\n                \"广度优先搜索（BFS）需要先进先出（FIFO）的队列行为，以确保节点按层次顺序被处理。这就是为什么 shift() 被用于 BFS 的原因\"\n              ),\n            ]),\n          ]),\n        ]),\n        _c(\"li\", [\n          _c(\"ol\", { attrs: { start: \"2\" } }, [\n            _c(\"li\", [\n              _vm._v(\n                \"如果使用 pop()，队列将变成后进先出（LIFO）的行为，这是深度优先搜索（DFS）的特性，而不是广度优先搜索。\\n*/\"\n              ),\n            ]),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const levelOrderN = function (root) {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length,\\n      curLevel = [];\\n    while (len--) {\\n      const node = queue.shift();\\n      curLevel.push(node.val);\\n      for (let item of node.children) {\\n        item && queue.push(item);\\n      }\\n    }\\n    res.push(curLevel);\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 515. 在每个树行中找最大值 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const largestValues = function (root) {\\n  if (!root) return [];\\n  let res = [],\\n    queue = [root];\\n  while (queue.length) {\\n    let len = queue.length,\\n      max = -Infinity;\\n    while (len--) {\\n      const node = queue.shift();\\n      max = Math.max(max, node.val);\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    res.push(max);\\n  }\\n  return res;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 116.填充每个节点的下一个右侧节点指针\\n/**\")]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\\nstruct Node {\\nint val;\\nNode *left;\\nNode *right;\\nNode *next;\\n}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。\\n*/\"\n          ),\n        ]),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const connect = function (root) {\\n if (!root) return root;\\n let queue = [root];\\n while (queue.length) {\\n   let len = queue.length;\\n   while (len--) {\\n     const node = queue.shift();\\n     if (len > 0) {\\n       node.next = queue[0];\\n     }\\n     node.left && queue.push(node.left);\\n     node.right && queue.push(node.right);\\n   }\\n }\\n return root;\\n};\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [\n        _vm._v(\n          \"// 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\"\n        ),\n      ]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const maxDepth = function (root) {\\n  let max = 0\\n  if (!root) return max;\\n  let queue = [root];\\n  while (queue.length) {\\n    let len = queue.length;\\n    max++\\n    while (len--) {\\n      const node = queue.shift();\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n  }\\n  return max;\\n}\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 111.二叉树的最小深度\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"const minDepth = function(root) {\\n  let min = 0,queue = [root]\\n  if (!root) return min\\n  while(queue.length) {\\n    let len = queue.length\\n    min++\\n    while(len--) {\\n      const node = queue.shift()\\n      if (!node.left && !node.right) return min\\n      node.left && queue.push(node.left)\\n      node.right && queue.push(node.right)\\n    }\\n  }\\n  return min\\n}\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n      _c(\"p\", [_vm._v(\"// 翻转二叉树\\n// 递归\")]),\n      _c(\"div\", { staticClass: \"language- extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-text\" } }, [\n          _c(\"code\", [\n            _vm._v(\n              \"var invertTree = function(root) {\\n  if(root == null) return root\\n  const rightNode = root.right\\n  root.right = invertTree(root.left)\\n  root.left = invertTree(rightNode)\\n  return root\\n}\\n\\n// 层序遍历\\nvar invertTree2 = function(root) {\\n  const invertNode = (root, left, right) => {\\n    const temp = left\\n    root.left = right\\n    root.right = temp\\n  }\\n  if (root == null) return root\\n  let queue = [root]\\n  while(queue.length) {\\n    let len = queue.length\\n    if (len--) {\\n      const node = queue.shift()\\n      invertNode(node, node.left, node.right)\\n      node.left && queue.push(node.left)\\n      node.right && queue.push(node.right)\\n    }\\n  }\\n  return root\\n}\\n// 迭代遍历 (前序遍历中左右); 入栈顺序为：右左 (栈是后进先出原则)\\nvar invertTree3 = function(root) {\\n  if (root == null) return root\\n  let queue = [root]\\n  while (queue.length) {\\n    let curNode = queue.pop()\\n    const temp = curNode.left\\n    curNode.left = curNode.right\\n    curNode.right = temp\\n\\n    // 将右子节点入栈\\n    if (curNode.right) queue.push(curNode.right)\\n\\n    // 将右子节点入栈\\n    if (curNode.left) queue.push(curNode.left)\\n  }\\n  return root\\n}\\n\"\n            ),\n          ]),\n        ]),\n      ]),\n    ])\n  },\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}]}