{"remainingRequest":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/javascript/algorithm.md?vue&type=template&id=1648357e","dependencies":[{"path":"/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/javascript/algorithm.md","mtime":1723100283626},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/babel-loader/lib/index.js","mtime":1723084153686},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1723084153489}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"js-算法\"><a class=\"header-anchor\" href=\"#js-算法\">#</a> js 算法</h1>\n<p>// 股票买卖1-买卖一次</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const maxProFit = (prices) =&gt; {\n  const len = prices.length;\n  const dp = new Array(len).fill([0, 0]);\n  dp[0] = [-prices[0], 0];\n  for (let i = 1; i &lt; len; i++) {\n    dp[i] = [\n      Math.max(dp[i - 1][0], -prices[i]),\n      Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]),\n    ];\n  }\n  return dp[len - 1][1];\n};\nconst max = maxProFit([1, 2, 8, 2, 6]);\nconsole.log(&quot;max: &quot;, max);\n\nvar maxProFit2 = (prices) =&gt; {\n  let lowerPrice = prices[0];\n  let profit = 0;\n  for (let i = 0; i &lt; prices.length; i++) {\n    lowerPrice = Math.min(lowerPrice, prices[i]);\n    profit = Math.max(profit, prices[i] - lowerPrice);\n  }\n  return profit;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 股票2-可以多次买卖</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var maxProFit3 = (prices) =&gt; {\n  let len = prices.length;\n  if (!prices.length || prices.length &lt; 2) return 0;\n  // let dp = new Array(len).fill([0,0])\n  let dp = Array.from(Array(len), () =&gt; Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  dp[0][1] = 0;\n  for (let i = 1; i &lt; len; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);\n  }\n  return dp[len - 1][1];\n};\nconst max3 = maxProFit3([1, 2, 8, 2, 6, 3, 9]);\nconsole.log(&quot;max3: &quot;, max3);\n\nvar maxProFit3_2 = (prices) =&gt; {\n  let len = prices.length,\n    have = -prices[0],\n    notHave = 0;\n  for (let i = 1; i &lt; len; i++) {\n    have = Math.max(have, notHave - prices[i]);\n    notHave = Math.max(notHave, have + prices[i]);\n  }\n  return notHave;\n};\nconst max3_2 = maxProFit3_2([1, 2, 8, 2, 6]);\nconsole.log(&quot;max3_2: &quot;, max3_2);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 股票3 ---最多买卖两次</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var maxProFit4 = (prices) =&gt; {\n  let len = prices.length,\n    dp = new Array(len).fill().map((x) =&gt; Array(5).fill(0));\n  dp[0][0] = 0;\n  dp[0][1] = -prices[0];\n  dp[0][3] = -prices[0];\n  for (let i = 1; i &lt; len; i++) {\n    dp[i][0] = dp[i - 1][0];\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n    dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n    dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n    dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n  }\n  return dp[len - 1][4];\n};\nconst max4 = maxProFit4([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\nconsole.log(&quot;max4: &quot;, max4);\n\nconst maxProfit4_2 = (prices) =&gt; {\n  const len = prices.length;\n  const dp = new Array(len).fill(0);\n  dp[1] = -prices[0];\n  dp[3] = -prices[0];\n  for (let i = 1; i &lt; len; i++) {\n    dp[1] = Math.max(dp[1], dp[0] - prices[i]);\n    dp[2] = Math.max(dp[2], dp[1] + prices[i]);\n    dp[3] = Math.max(dp[3], dp[2] - prices[i]);\n    dp[4] = Math.max(dp[4], dp[3] + prices[i]);\n  }\n  return dp[4];\n};\n\nconst max4_2 = maxProfit4_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11]);\nconsole.log(&quot;max4_2: &quot;, max4_2);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 股票--含有冷冻期</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const maxProfit5 = (prices) =&gt; {\n  const len = prices.length;\n  if (len &lt; 2) {\n    return 0;\n  } else if (len &lt; 3) {\n    return Math.max(0, prices[1] - prices[0]);\n  }\n  const dp = Array.from(Array(len), () =&gt; Array(4).fill(0));\n  dp[0][0] = 0 - prices[0];\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\n  // 2:今天卖出股票\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\n  for (let i = 1; i &lt; len; i++) {\n    dp[i][0] = Math.max(\n      dp[i - 1][0],\n      Math.max(dp[i - 1][1], dp[i - 1][3]) - prices[i]\n    );\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);\n    dp[i][2] = dp[i - 1][0] + prices[i];\n    dp[i][3] = dp[i - 1][2];\n  }\n  return Math.max(dp[len - 1][1], dp[len - 1][2], dp[len - 1][3]);\n};\n\nconst max5 = maxProfit5([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\nconsole.log(&quot;max5: &quot;, max5);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 股票--含有冷冻期_2</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const maxProfit5_2 = (prices) =&gt; {\n  // 0:持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）\n  // 1:不持有股票状态(-保持卖出的状态)-两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）\n  // 2:今天卖出股票\n  // 3:冷冻期-今天为冷冻期状态，但冷冻期状态不可持续，只有一天！\n  const len = prices.length;\n  const dp = new Array(len).fill(0);\n  for (let i = 1; i &lt; len; i++) {\n    const temp1 = dp[0];\n    const temp2 = dp[2];\n    dp[0] = Math.max(dp[0], Math.max(dp[1], dp[3]) - prices[i]);\n    dp[1] = Math.max(dp[1], dp[3]);\n    dp[2] = temp1 + prices[i];\n    dp[3] = temp2;\n  }\n  return Math.max(...dp);\n};\n\nconst max5_2 = maxProfit5_2([1, 2, 8, 2, 6, 1, 5, 8, 3, 11, 5, 8, 3, 11], 3);\nconsole.log(&quot;max5_2: &quot;, max5_2);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**</p>\n<ul>\n<li>给定一个含有 n 个正整数的数组和一个正整数 target 。</li>\n</ul>\n<p>找出该数组中满足其总和大于等于 target 的长度最小的 连续\n子数组\n子数组\n子数组 是数组中连续的 非空 元素序列。</p>\n<p>[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0\n*/\n//  长度最小的子数组</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var minSubArrayLen = function (target, nums) {\n  let left = (right = 0),\n    len = nums.length,\n    sum = 0,\n    res = len + 1;\n  while (right &lt; len) {\n    sum += nums[right];\n    while (sum &gt;= target) {\n      res = Math.min(res, right - left + 1);\n      sum -= nums[left++];\n    }\n    right++;\n  }\n  return res &gt; len ? 0 : res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**</p>\n<ul>\n<li>\n<ol start=\"59\">\n<li>螺旋矩阵 II (https://leetcode.cn/problems/spiral-matrix-ii/description/)</li>\n</ol>\n</li>\n<li>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</li>\n<li></li>\n</ul>\n<p>*/</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var generateMatrix = function (n) {\n  let starX = (startY = 0),\n    offset = 1,\n    loop = Math.floor(n / 2),\n    mid = Math.floor(n / 2),\n    count = 1;\n  let res = Array(n)\n    .fill(0)\n    .map(() =&gt; Array(n).fill(0));\n\n  while (loop--) {\n    let row = starX,\n      col = startY;\n    // 上行从左到右\n    for (; col &lt; n - offset; col++) {\n      res[row][col] = count++;\n    }\n    // 右列从上到下\n    for (; row &lt; n - offset; row++) {\n      res[row][col] = count++;\n    }\n    // 下行从右到左\n    for (; col &gt; startY; col--) {\n      res[row][col] = count++;\n    }\n    // 左列从下到上\n    for (; row &gt; starX; row--) {\n      res[row][col] = count++;\n    }\n    starX++;\n    startY++;\n    offset++;\n  }\n  if (n % 2 === 1) {\n    res[mid][mid] = count;\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 链表</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class ListNode {\n  constructor(value, next) {\n    this.val = value;\n    this.next = next;\n  }\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 删除列表</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var removeElements = function (head, val) {\n  const dummyHead = new ListNode(0, head);\n  let cur = dummyHead;\n  while (cur.next) {\n    if (cur.next.val === val) {\n      cur.next = cur.next.next;\n      continue;\n    }\n    cur = cur.next;\n  }\n  return dummyHead.next;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 设计链表</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var ListNode = function (val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n};\n\nvar MyLinkedList = function () {\n  this.size = 0;\n  this.head = new ListNode(0);\n};\n\n/**\n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.getNode = function (index) {\n  if (index &lt; 0 || index &gt;= this.size) return -1;\n  let cur = this.head;\n  while (index-- &gt;= 0) {\n    cur = cur.next;\n  }\n  return cur.val;\n};\n\nMyLinkedList.prototype.get = function (index) {\n  return this.getNode(index);\n};\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function (val) {\n  this.addAtIndex(0, val);\n};\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function (val) {\n  this.addAtIndex(this.size, val);\n};\n\n/**\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function (index, val) {\n  if (index &gt; this.size) return;\n  index = Math.max(0, index);\n  this.size++;\n  let cur = this.head;\n  while (index--) {\n    cur = cur.next;\n  }\n  let toAdd = new ListNode(val);\n  toAdd.next = cur.next;\n  cur.next = toAdd;\n};\n\n/**\n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function (index) {\n  if (index &lt; 0 || index &gt;= this.size) return;\n  this.size--;\n  let cur = this.head;\n  while (index--) {\n    cur = cur.next;\n  }\n  cur.next = cur.next.next;\n};\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**</p>\n<ul>\n<li>翻转链表</li>\n<li>@param {*} head</li>\n<li>@returns\n*/\n//\n// 双指针</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var reverseList = function (head) {\n  if (!head || !head.next) return head;\n  let pre = null,\n    cur = head,\n    temp = null;\n  while (cur) {\n    temp = cur.next;\n    cur.next = pre;\n    pre = cur;\n    cur = temp;\n  }\n  return pre;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 翻转链表-递归1</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var reverse = function (pre, head) {\n  if (!head) return pre;\n  let temp = head.next;\n  head.next = pre;\n  pre = head;\n  reverse(pre, temp);\n};\nvar reverseList = function (head) {\n  reverse(null, head);\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 24. 两两交换链表中的节点</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var swapPairs = function (head) {\n  let ret = new ListNode(0, head),\n    temp = ret;\n  while (temp.next &amp;&amp; temp.next.next) {\n    let cur = temp.next.next,\n      pre = temp.next;\n    pre.next = cur.next;\n    cur.next = pre;\n    temp.next = cur;\n    temp = pre;\n  }\n  return ret.next;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 19. 删除链表的倒数第 N 个结点</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var removeNthFromEnd = function (head, n) {\n  let ret = new ListNode(0, head),\n    slow = (fast = ret);\n  while (n--) {\n    fast = fast.next;\n  }\n  while (fast.next !== null) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n  slow.next = slow.next.next;\n  return ret.next;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 142. 环形链表 II (给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。)</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var detectCycle = function (head) {\n  if (!head || !head.next) return null;\n  let slow = (fast = head);\n  while (fast &amp;&amp; fast.next &amp;&amp; fast.next.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (fast === slow) {\n      slow = head;\n      while (fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n      }\n      return slow;\n    }\n  }\n  return null;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 02.07. 链表相交 1</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var getIntersectionNode1 = function (headA, headB) {\n  if (!headA || !headB) return null;\n  let curA = headA,\n    curB = headB;\n  while (curA !== curB) {\n    curA = curA ? curA.next : headB;\n    curB = curB ? curB.next : headA;\n  }\n  return curA;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 02.07. 链表相交 2</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var getIntersectionNode2 = function (headA, headB) {\n  if (!headA || !headB) return null;\n  const visited = new Set();\n  let temp = headA;\n  while (temp) {\n    visited.add(temp);\n    temp = temp.next;\n  }\n  temp = headB;\n  while (temp) {\n    if (visited.has(temp)) return temp;\n    temp = temp.next;\n  }\n  return null;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n// 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var isAnagram = function (s, t) {\n  if (s.length !== t.length) return false;\n  let ret = new Array(26).fill(0),\n    base = &quot;a&quot;.charCodeAt();\n  for (const i of s) {\n    ret[i.charCodeAt() - base]++;\n  }\n  for (const i of t) {\n    if (!ret[i.charCodeAt() - base]) return false;\n    ret[i.charCodeAt() - base]--;\n  }\n  return true;\n};\nvar isAnagram2 = function (s, t) {\n  if (s.length !== t.length) return false;\n  let ret = new Map();\n  for (const i of s) {\n    ret.set(i, (ret.get(i) || 0) + 1);\n  }\n  for (const i of t) {\n    if (!ret.get(i)) return false;\n    ret.set(i, ret.get(i) - 1);\n  }\n  return true;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的 交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n// https://leetcode.cn/problems/intersection-of-two-arrays/</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var intersection = function (nums1, nums2) {\n  if (nums1.length &lt; nums2.length) {\n    [nums2, nums1] = [nums1, nums2];\n  }\n  let ret1 = new Set(nums1),\n    ret2 = new Set();\n  for (let i = 0; i &lt; nums2.length; i++) {\n    ret1.has(nums2[i]) &amp;&amp; ret2.add(nums2[i]);\n  }\n  return Array.from(ret2);\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 202. 快乐数\n//「快乐数」 定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n// 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n// 如果这个过程 结果为 1，那么这个数就是快乐数。\n// 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var isHappy = function (n) {\n  let m = new Set();\n  let getSum = (num) =&gt; {\n    let sum = 0;\n    while (num) {\n      sum += (num % 10) ** 2;\n      num = Math.floor(num / 10);\n    }\n  };\n  // 1\n  // while(true) {\n  //   if (m.has(n)) return false\n  //   if (n === 1) return true\n  //   n = getSum(n)\n  //   m.add(n)\n  // }\n  // 2\n  while (n !== 1 &amp;&amp; !m.has(n)) {\n    m.add(n);\n    n = getSum(n);\n  }\n  return n === 1;\n};\nisHappy(19);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 1. 两数之和</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var twoSum = function (nums, target) {\n  let has = {};\n  for (let i = 0; i &lt; nums.length; i++) {\n    if (has[target - nums[i]] !== undefined) {\n      return [i, has[target - nums[i]]];\n    }\n    has[nums[i]] = i;\n  }\n  return [];\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var fourSumCount = function (nums1, nums2, nums3, nums4) {\n  let map = new Map();\n  nums1.forEach((n1) =&gt;\n    nums2.forEach((n2) =&gt; map.set(n1 + n2, (map.get(n1 + n2) || 0) + 1))\n  );\n  let count = 0;\n  for (let n3 of nums3) {\n    for (let n4 of nums4) {\n      if (map.has(-(n3 + n4))) {\n        count += map.get(-(n3 + n4));\n      }\n    }\n  }\n  return count;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 383. 赎金信 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var canConstruct = function (ransomNote, magazine) {\n  let strArr = Array(26).fill(0),\n    base = &quot;a&quot;.charCodeAt();\n  for (let i of magazine) {\n    strArr[i.charCodeAt() - base]++;\n  }\n  for (let u of ransomNote) {\n    let index = u.charCodeAt() - base;\n    if (!strArr[index]) return false;\n    strArr[index]--;\n  }\n  return true;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 15. 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n// 你返回所有和为 0 且不重复的三元组。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var threeSum = function (nums) {\n  let res = [],\n    len = nums.length;\n  nums.sort((a, b) =&gt; a - b);\n  for (let i = 0; i &lt; len; i++) {\n    let l = i + 1,\n      r = len - 1,\n      iNum = nums[i];\n    if (iNum &gt; 0) return res;\n    if (iNum === nums[i - 1]) continue;\n    while (l &lt; r) {\n      let lNum = nums[l],\n        rNum = nums[r],\n        threeSum = iNum + lNum + rNum;\n      if (threeSum &lt; 0) l++;\n      else if (threeSum &gt; 0) r--;\n      else {\n        res.push([iNum, lNum, rNum]);\n        while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) {\n          l++;\n        }\n        while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) {\n          r--;\n        }\n        l++;\n        r--;\n      }\n    }\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var fourSum = function (nums, target) {\n  let res = [],\n    len = nums.length;\n  if (len &lt; 4) return [];\n  nums.sort((a, b) =&gt; a - b);\n  for (let i = 0; i &lt; len - 3; i++) {\n    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;\n\n    for (let j = i + 1; j &lt; len - 2; j++) {\n      if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue;\n\n      let l = j + 1,\n        r = len - 1;\n      while (l &lt; r) {\n        const sum = nums[i] + nums[j] + nums[l] + nums[r];\n        if (sum &gt; target) r--;\n        else if (sum &lt; target) l++;\n        else {\n          res.push([nums[i], nums[j], nums[l], nums[r]]);\n          // while (l &lt; r &amp;&amp; nums[l] === nums[l + 1]) {\n          //   l++\n          // }\n          // while (l &lt; r &amp;&amp; nums[r] === nums[r - 1]) {\n          //   r--;\n          // }\n          // l++\n          // r--\n          while (l &lt; r &amp;&amp; nums[l] === nums[++l]);\n          while (l &lt; r &amp;&amp; nums[r] === nums[--r]);\n        }\n      }\n    }\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 344. 反转字符串\n// 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var reverseString = function (s) {\n  // let l = -1,r = s.length;\n  // while(++l &lt; --r) [s[l], s[r]] = [s[r], s[l]]\n  let l = 0,\n    r = s.length - 1,\n    temp = null;\n  while (l &lt; r) {\n    temp = s[l];\n    s[l] = s[r];\n    s[r] = temp;\n    l++;\n    r--;\n  }\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 541. 反转字符串 II\n// 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var reverseStr = function (s, k) {\n  let len = s.length,\n    resArr = s.split(&quot;&quot;);\n  // for (let i = 0; i &lt; len; i += 2 * k) {\n  //   let l = i - 1,\n  //     r = i + k &gt; len ? len : i + k;\n  //   while (++l &lt; --r) [[resArr[l]], resArr[r]] = [[resArr[r]], resArr[l]];\n  // }\n  for (let i = 0; i &lt; len; i += 2 * k) {\n    let l = i - 1,\n      r = i + k &gt; len ? len : i + k,\n      temp = null;\n    while (++l &lt; --r) {\n      temp = resArr[l];\n      resArr[l] = resArr[r];\n      resArr[r] = temp;\n    }\n  }\n  return resArr.join(&quot;&quot;);\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 替换数字（第八期模拟笔试）\n// 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 &quot;a1b2c3&quot;，函数应该将其转换为 &quot;anumberbnumbercnumber&quot;。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>let numberToStringFn = function (str) {\n  let num0 = &quot;0&quot;.charCodeAt(),\n    num9 = &quot;9&quot;.charCodeAt(),\n    a = &quot;a&quot;.charCodeAt(),\n    z = &quot;z&quot;.charCodeAt(),\n    len = str.length,\n    n = 0;\n  let isNumber = (code) =&gt; {\n    code = code.charCodeAt();\n    return code &gt;= num0 &amp;&amp; code &lt;= num9;\n  };\n  let isAz = (code) =&gt; {\n    code = code.charCodeAt();\n    return code &gt;= a &amp;&amp; code &lt;= z;\n  };\n  // 计算新数组长度\n  for (let i = 0; i &lt; len; i++) {\n    if (isNumber(str[i])) {\n      n += 6;\n    } else if (isAz(str[i])) {\n      n += 1;\n    } else {\n      n += 1;\n    }\n  }\n  let newArr = Array(n).fill(&quot;&quot;),\n    index = n - 1;\n  for (let i = len - 1; i &gt;= 0; i--) {\n    if (isAz(str[i])) {\n      // 字符串\n      newArr[index] = str[i];\n      index--;\n    } else if (isNumber(str[i])) {\n      // number\n      newArr[index] = &quot;r&quot;;\n      newArr[index - 1] = &quot;e&quot;;\n      newArr[index - 2] = &quot;b&quot;;\n      newArr[index - 3] = &quot;m&quot;;\n      newArr[index - 4] = &quot;u&quot;;\n      newArr[index - 5] = &quot;n&quot;;\n      index -= 6;\n    }\n  }\n  console.log(newArr.join(&quot;&quot;));\n  console.log(newArr.join(&quot;&quot;).length);\n};\n\nnumberToStringFn(&quot;12jsd3k2n5k6k9&quot;);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 151. 反转字符串中的单词\n/**</p>\n<ul>\n<li>给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n*/</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var reverseWords = function (s) {\n  // function removeExtraSpaces(strArr) {\n  //   let slowIndex = 0, fastIndex = 0;\n  //   while(fastIndex &lt; strArr.length) {\n  //     if (strArr[fastIndex] === &#39; &#39; &amp;&amp; (fastIndex === 0 || strArr[fastIndex - 1] === &#39; &#39;)) {\n  //       fastIndex++\n  //     } else {\n  //       strArr[slowIndex++] = strArr[fastIndex++]\n  //     }\n  //   }\n  //   strArr.length = strArr[slowIndex - 1] === &#39; &#39; ? slowIndex - 1 : slowIndex\n  // }\n  // function reverse(strArr, start, end) {\n  //   let l = start,r = end;\n  //   while(l &lt; r) {\n  //     [strArr[r], strArr[l]] = [strArr[l], strArr[r]]\n  //     l++\n  //     r--\n  //   }\n  // }\n\n  // const strArr = Array.from(s)\n  // removeExtraSpaces(strArr)\n  // // 翻转\n  // reverse(strArr, 0, strArr.length - 1)\n  // let start = 0\n  // for(let i = 0; i &lt;= strArr.length;i++) {\n  //   if (strArr[i] === &#39; &#39; || i === strArr.length) {\n  //     reverse(strArr, start, i - 1)\n  //     start = i + 1\n  //   }\n  // }\n  // return strArr.join(&#39;&#39;)\n\n  // 2--------\n  const strArr = s.trim().split(/\\s+/);\n  let i = 0,\n    j = strArr.length - 1;\n  for (; i &lt;= j; i++, j--) {\n    // 1----------\n    // [strArr[j], strArr[i]] = [strArr[i], strArr[j]];\n\n    // 2----------\n    let tmp = sArr[i];\n    sArr[i] = sArr[j];\n    sArr[j] = tmp;\n  }\n  return strArr.join(&quot; &quot;);\n};\nreverseWords(&quot;asdf sd adf sd fe&quot;);\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 右旋字符串</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>function reverseStrFn(arr, start, end) {\n  let l = start,\n    r = end;\n  while (l &lt; r) {\n    [arr[r], arr[l]] = [arr[l], arr[r]];\n    l++;\n    r--;\n  }\n  return arr;\n}\n\nfunction reVerArr(arr, n) {\n  reverseStrFn(arr, 0, arr.length - 1);\n  reverseStrFn(arr, 0, n - 1);\n  reverseStrFn(arr, n, arr.length - 1);\n  console.log(&quot;arr: &quot;, arr.join(&quot;&quot;));\n  return arr.join(&quot;&quot;);\n}\nlet arr = Array.from(&quot;asbejkl&quot;);\nreVerArr(arr, 3);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 28. 找出字符串中第一个匹配项的下标\n/**</p>\n<ul>\n<li>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</li>\n<li>@param {*} haystack</li>\n<li>@param {*} needle\n*/</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var strStr = function (haystack, needle) {\n if (!needle.length) return 0;\n var getNext = (needle) =&gt; {\n   let j = 0,\n     next = [];\n   next[0] = 0;\n   for (let i = 1; i &lt; needle.length; i++) {\n     while (j &gt; 0 &amp;&amp; needle[i] !== needle[j]) {\n       console.log(&quot;j: &quot;, j);\n       j = next[j - 1];\n     }\n     if (needle[i] === needle[j]) {\n       j++;\n     }\n     next[i] = j;\n   }\n   return next;\n };\n let next = getNext(needle);\n let j = 0;\n for (let i = 0; i &lt; haystack.length; i++) {\n   while (j &gt; 0 &amp;&amp; haystack[i] !== needle[j]) {\n     j = next[j - 1];\n   }\n   if (haystack[i] === needle[j]) {\n     j++;\n   }\n   if (j === needle.length) {\n     return i + 1 - needle.length;\n   }\n }\n return -1;\n};\n\nconst f = strStr(&quot;6sadbutsad&quot;, &quot;sad&quot;);\nconsole.log(&quot;f: &quot;, f);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 459.重复的子字符串 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var repeatedSubstringPattern = function (s) {\n  let len = s.length;\n  if (!len) return false;\n  let getNext = (s) =&gt; {\n    let j = 0,\n      next = [0];\n    for (let i = 1; i &lt; s.length; i++) {\n      while (j &gt; 0 &amp;&amp; s[i] !== s[j]) {\n        j = next[j - 1];\n      }\n      if (s[i] === s[j]) {\n        j++;\n      }\n      next.push(j);\n    }\n    return next;\n  };\n  let next = getNext(s),\n    len2 = next.length;\n  return next[len2 - 1] !== 0 &amp;&amp; len % (len - next[len2 - 1]) === 0;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var removeElement = function (nums, val) {\n  // let k = 0\n  // for(let i = 0; i &lt; nums.length; i++) {\n  //   if (nums[i] !== val) {\n  //     nums[k++] = nums[i]\n  //   }\n  // }\n  // // nums.length = k\n  // return k\n  let l = 0,\n    r = nums.length;\n  while (l &lt; r) {\n    if (nums[l] === val) {\n      nums[l] = nums[--r];\n    } else {\n      l++;\n    }\n  }\n  nums.length = l;\n  console.log(&quot;nums: &quot;, nums);\n  return l;\n};\nremoveElement([1, 2, 3, 3, 5, 5], 5);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 232. 用栈实现队列 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var MyQueueFn = () =&gt; {\n  var MyQueue = function () {\n    this.stackIn = [];\n    this.stackOut = [];\n  };\n\n  /**\n   * @param {number} x\n   * @return {void}\n   */\n  MyQueue.prototype.push = function (x) {\n    this.stackIn.push(x);\n  };\n\n  /**\n   * @return {number}\n   */\n  MyQueue.prototype.pop = function () {\n    const size = this.stackOut.length;\n    if (size) {\n      return this.stackOut.pop();\n    }\n    while (this.stackIn.length) {\n      this.stackOut.push(this.stackIn.pop());\n    }\n    return this.stackOut.pop();\n  };\n\n  /**\n   * @return {number}\n   */\n  MyQueue.prototype.peek = function () {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n  };\n\n  /**\n   * @return {boolean}\n   */\n  MyQueue.prototype.empty = function () {\n    return !this.stackIn.length &amp;&amp; !this.stackOut.length;\n  };\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 225. 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var MyStackFn = () =&gt; {\n  var MyStack = function () {\n    this.queue1 = [];\n    this.queue2 = [];\n  };\n  /**\n   * @param {number} x\n   * @return {void}\n   */\n  MyStack.prototype.push = function (x) {\n    this.queue1.push(x);\n  };\n\n  /**\n   * @return {number}\n   */\n  MyStack.prototype.pop = function () {\n    if (!this.queue1.length) {\n      [this.queue2, this.queue1] = [this.queue1, this.queue2];\n    }\n    while (this.queue1.length &gt; 1) {\n      this.queue2.push(this.queue1.shift());\n    }\n    return this.queue1.shift();\n  };\n\n  /**\n   * @return {number}\n   */\n  MyStack.prototype.top = function () {\n    var x = this.pop();\n    this.queue1.push(x);\n    return x;\n  };\n\n  /**\n   * @return {boolean}\n   */\n  MyStack.prototype.empty = function () {\n    return !this.queue1.length &amp;&amp; !this.queue2.length;\n  };\n};\n\n// 用一个队列实现-------\nclass MyStack {\n  constructor() {\n    this.queue = [];\n  }\n\n  push(x) {\n    this.queue.push(x);\n  }\n\n  pop() {\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\n    let size = this.queue.length;\n    while (size-- &gt; 1) {\n      this.queue.push(this.queue.shift());\n    }\n    // 移除并返回最后一个元素\n    return this.queue.shift();\n  }\n  top() {\n    // 将队列前面的元素（除了最后一个）全部移到队列末尾\n    const x = this.pop();\n    this.queue.push(x);\n  }\n  empty() {\n    return this.queue.length === 0;\n  }\n}\n\n// 示例用法：\nconst stack = new MyStack();\nstack.push(1);\nstack.push(2);\nconsole.log(stack.top()); // 输出 2\nconsole.log(stack.pop()); // 输出 2\nconsole.log(stack.empty()); // 输出 false\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**</p>\n<ul>\n<li>有效字符串需满足：\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n*/\n// 20. 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var isValid = function (s) {\n  // let list = [];\n  // for(let i of s) {\n  //   switch (i) {\n  //     case &#39;(&#39;:\n  //       list.push(&#39;)&#39;)\n  //       break;\n  //     case &#39;[&#39;:\n  //       list.push(&#39;]&#39;)\n  //       break;\n  //     case &#39;{&#39;:\n  //       list.push(&#39;}&#39;)\n  //       break;\n  //     default:\n  //       if (i !== list.pop()) return false\n  //       break;\n  //   }\n  // }\n  // return !list.length\n  let list = [],\n    map = {\n      &quot;(&quot;: &quot;)&quot;,\n      &quot;[&quot;: &quot;]&quot;,\n      &quot;{&quot;: &quot;}&quot;,\n    };\n  for (let i of s) {\n    if (map[i]) {\n      list.push(i);\n      continue;\n    }\n    if (map[list.pop()] !== i) return false;\n  }\n  return !list.length;\n};\nisValid(&quot;((&quot;);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 1047. 删除字符串中的所有相邻重复项</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var removeDuplicates = function (s) {\n  // var list = []\n  // for(let i of s) {\n  //   let lastVal = list.length ? list[list.length - 1] : null\n  //   if (i === lastVal) {\n  //     list.pop()\n  //   } else {\n  //     list.push(i)\n  //   }\n  // }\n  // return list.join(&#39;&#39;)\n  let list = [...s],\n    top = -1;\n  for (let i of s) {\n    if (top === -1 || list[top] !== i) {\n      list[++top] = i;\n    } else {\n      top--;\n    }\n  }\n  list.length = top + 1;\n  console.log(&quot;list.join&quot;, list.join(&quot;&quot;));\n  return list.join(&quot;&quot;);\n};\nremoveDuplicates(&quot;dbccab&quot;);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 150. 逆波兰表达式求值 给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。请你计算该表达式。返回一个表示表达式值的整数。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var evalRPN = function (tokens) {\n  let stack = [];\n  for (const token of tokens) {\n    if (isNaN(Number(token))) {\n      // 重点 isNaN()\n      const n2 = stack.pop(); // 出栈两个数字\n      const n1 = stack.pop();\n      switch (token) {\n        case &quot;+&quot;:\n          stack.push(n1 + n2);\n          break;\n        case &quot;-&quot;:\n          stack.push(n1 - n2);\n          break;\n        case &quot;*&quot;:\n          stack.push(n1 * n2);\n          break;\n        case &quot;/&quot;:\n          const st = (n1 / n2) | 0; // 重点 | 0\n          stack.push(st);\n          break;\n      }\n    } else {\n      stack.push(Number(token));\n    }\n  }\n  console.log(&quot;stack[0]: &quot;, stack[0]);\n  return stack[0];\n};\n\nevalRPN([&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。</p>\n<p>/**</p>\n<ul>\n<li>@param {number[]} nums</li>\n<li>@param {number} k</li>\n<li>@return {number[]}\n*/</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var maxSlidingWindow = function (nums, k) {\n class MonoQueue {\n   queue;\n   constructor() {\n     this.queue = [];\n   }\n   enqueue(value) {\n     let back = this.queue[this.queue.length - 1];\n     while (back !== undefined &amp;&amp; back &lt; value) {\n       this.queue.pop();\n       back = this.queue[this.queue.length - 1];\n     }\n     this.queue.push(value);\n   }\n   dequeue(value) {\n     const front = this.front();\n     if (front === value) {\n       this.queue.shift();\n     }\n   }\n   front() {\n     return this.queue[0];\n   }\n }\n const helpQueue = new MonoQueue();\n let i = 0,\n   j = 0,\n   resArr = [];\n // 先将前k个参数循环一遍\n while (j &lt; k) {\n   helpQueue.enqueue(nums[j++]);\n }\n resArr.push(helpQueue.front());\n // 再让i从0开始 如果有一样的走过的参数从列表里面删除掉\n while (j &lt; nums.length) {\n   helpQueue.enqueue(nums[j++]);\n   helpQueue.dequeue(nums[i++]);\n   resArr.push(helpQueue.front());\n }\n return resArr;\n};\nmaxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3);\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**\n*</p>\n<ul>\n<li>在 JavaScript 中，小顶堆通常使用数组来实现。数组表示小顶堆时，元素按层级顺序存储，</li>\n<li>即父节点的索引为 i，其左子节点的索引为 2*i + 1，</li>\n<li>右子节点的索引为 2*i + 2。这种存储方式使得堆的操作非常高效。</li>\n<li></li>\n<li>数组表示的具体规则\n根节点：根节点在数组中的索引为 0。\n左子节点：对于索引为 i 的节点，左子节点的索引为 2<em>i + 1。\n右子节点：对于索引为 i 的节点，右子节点的索引为 2</em>i + 2。\n父节点：对于索引为 i 的节点，父节点的索引为 Math.floor((i - 1) / 2)。</li>\n<li></li>\n</ul>\n<p>*/</p>\n<p>// js实现小顶堆</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class MinHeap {\n  constructor(compareFn) {\n    this.head = [];\n    this.compareFn = compareFn;\n  }\n  getParentIndex(index) {\n    return Math.floor((index - 1) / 2);\n  }\n  getLeftChildIndex(index) {\n    return index * 2 + 1;\n  }\n  getRightChildIndex(index) {\n    return index * 2 + 2;\n  }\n  swap(index1, index2) {\n    [this.head[index2], this.head[index1]] = [\n      this.head[index1],\n      this.head[index2],\n    ];\n  }\n  compare(index1, index2) {\n    if (this.head[index1] === undefined) return 1;\n    if (this.head[index2] === undefined) return -1;\n    return this.compareFn(this.head[index1], this.head[index2]);\n  }\n  insert(val) {\n    this.head.push(val);\n    this.headPiFyUp();\n  }\n  // 向上堆积\n  headPiFyUp() {\n    let index = this.head.length - 1;\n    while (index &gt; 0) {\n      let parentIndex = this.getParentIndex(index);\n      //  this.head[index] &lt; this.head[parentIndex]\n      if (this.compare(index, parentIndex) &lt; 0) {\n        this.swap(index, parentIndex);\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n  remove() {\n    let len = this.head.length;\n    if (!len) return null;\n    if (len === 1) return this.head.pop();\n    const root = this.head[0];\n    this.head[0] = this.head.pop();\n    this.headPiFyDown(0);\n    return root;\n  }\n  // 向下堆积\n  headPiFyDown(index) {\n    let smallest = index;\n    const leftChildrenIndex = this.getLeftChildIndex(index);\n    const rightChildrenIndex = this.getRightChildIndex(index);\n    // if (leftChildrenIndex &lt; this.head.length &amp;&amp; this.head[leftChildrenIndex] &lt; this.head[smallest]) {\n    if (\n      leftChildrenIndex &lt; this.head.length &amp;&amp;\n      this.compare(leftChildrenIndex, smallest) &lt; 0\n    ) {\n      smallest = leftChildrenIndex;\n    }\n    // if (rightChildrenIndex &lt; this.head.length &amp;&amp; this.head[rightChildrenIndex] &lt; this.head[smallest]) {\n    if (\n      rightChildrenIndex &lt; this.head.length &amp;&amp;\n      this.compare(rightChildrenIndex, smallest) &lt; 0\n    ) {\n      smallest = rightChildrenIndex;\n    }\n    if (smallest !== index) {\n      // 说明进行了转换\n      this.swap(index, smallest);\n      this.headPiFyDown(smallest);\n    }\n  }\n  getMin() {\n    return this.head[0];\n  }\n  size() {\n    return this.head.length;\n  }\n  isEmpty() {\n    return !this.head.length;\n  }\n  buildHeap(arr) {\n    this.head = arr;\n    for (let i = Math.floor(this.head.length / 2) - 1; i &gt;= 0; i--) {\n      this.headPiFyDown(i);\n    }\n  }\n  printHeap() {\n    console.log(this.head);\n  }\n}\n\n// const testMinHeap = () =&gt; {\n//   const minHeap = new MinHeap((a, b) =&gt; a - b)\n//   minHeap.insert(10)\n//   minHeap.insert(1)\n//   minHeap.insert(2)\n//   minHeap.insert(3)\n//   minHeap.insert(4)\n//   minHeap.printHeap()\n\n//   const minVal1 = minHeap.getMin()\n//   console.log(&#39;minVal1: &#39;, minVal1);\n\n//   minHeap.remove()\n//   minHeap.printHeap()\n\n//   const minVal2 = minHeap.getMin()\n//   console.log(&#39;minVal2: &#39;, minVal2);\n\n//   minHeap.insert(5)\n//   minHeap.printHeap()\n\n//   const minVal3 = minHeap.getMin()\n//   console.log(&#39;minVal3: &#39;, minVal3);\n// }\n// testMinHeap()\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 347. 前 K 个高频元素 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var topKFrequent = function (nums, k) {\n  const map = new Map();\n  for (const i of nums) {\n    map.set(i, (map.get(i) || 0) + 1);\n  }\n\n  const heap = new MinHeap((a, b) =&gt; a[1] - b[1]);\n\n  for (const i of map.entries()) {\n    heap.insert(i);\n    if (heap.size() &gt; k) {\n      heap.remove();\n    }\n  }\n  const res = [];\n  heap.printHeap();\n  for (let i = heap.size() - 1; i &gt;= 0; i--) {\n    res.push(heap.remove()[0]);\n  }\n  console.log(&quot;res: &quot;, res);\n  return res;\n};\n\ntopKFrequent([1, 1, 1, 2, 2, 3], 2);\n\nconst topKFrequent2 = (nums, k) =&gt; {\n  const map = new Map();\n  for (const i of nums) {\n    map.set(i, (map.get(i) || 0) + 1);\n  }\n  //返回一个按出现次数降序的二维数组\n  let sortArray = Array.from(map).sort((a, b) =&gt; b[1] - a[1]),\n    res = [];\n  for (let i = 0; i &lt; k; i++) {\n    res.push(sortArray[i][0]);\n  }\n  console.log(&quot;res: &quot;, res);\n  return res;\n};\ntopKFrequent2([1, 1, 1, 2, 2, 3], 2);\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 二叉树节点类</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass BinaryTree {\n  constructor() {\n    this.root = null;\n  }\n  insert(value) {\n    const newNode = new TreeNode(value);\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      this.insertNode(this.root, newNode);\n    }\n  }\n  insertNode(node, newNode) {\n    if (newNode.value &lt; node.value) {\n      // 新节点放到left\n      if (node.left === null) {\n        node.left = newNode;\n      } else {\n        this.insertNode(node.left, newNode);\n      }\n    } else {\n      // 新节点放到right\n      if (node.right === null) {\n        node.right = newNode;\n      } else {\n        this.insertNode(node.right, newNode);\n      }\n    }\n  }\n  search(value) {\n    return this.searchNode(this.root, value);\n  }\n  searchNode(root, value) {\n    if (root === null) return false;\n    if (value &lt; root.value) {\n      this.searchNode(root.left, value);\n    } else if (value &gt; root.value) {\n      this.searchNode(root.right, value);\n    } else {\n      return true;\n    }\n  }\n  /**\n   * \n   * 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式\n    前序遍历：中左右\n    中序遍历：左中右\n    后序遍历：左右中\n   */\n  // 前序遍历\n  preOrder(node = this.root) {\n    if (node !== null) {\n      console.log(node.value);\n      this.preOrder(node.left);\n      this.preOrder(node.right);\n    }\n  }\n  // 中序遍历\n  inOrder(node = this.root) {\n    if (node !== null) {\n      this.preOrder(node.left);\n      console.log(node.value);\n      this.preOrder(node.right);\n    }\n  }\n  // 后序遍历\n  postOrder(node = this.root) {\n    if (node !== null) {\n      this.preOrder(node.left);\n      this.preOrder(node.right);\n      console.log(node.value);\n    }\n  }\n}\n\nconst treeTestFn = () =&gt; {\n  const tree = new BinaryTree();\n  tree.insert(7);\n  tree.insert(4);\n  tree.insert(9);\n  tree.insert(1);\n  tree.insert(6);\n  tree.insert(8);\n  tree.insert(10);\n\n  console.log(&quot;中序遍历&quot;);\n  tree.inOrder();\n\n  console.log(&quot;前序遍历&quot;);\n  tree.preOrderOrder();\n\n  console.log(&quot;后序遍历&quot;);\n  tree.postOrder();\n\n  console.log(&quot;查找节点&quot;);\n  console.log(tree.search(6));\n  console.log(tree.search(15));\n};\ntreeTestFn();\n\nconst binaryTreeTraversal2 = () =&gt; {\n  // 迭代法遍历\n  // ---前序遍历---: (中左右) 栈进入顺序 右 -&gt; 左; 出栈  中 -&gt; 左 -&gt; 右\n  const preOrderTraversal = (root) =&gt; {\n    let res = [];\n    if (!root) return res;\n    let stack = [root],\n      cur = null;\n    while (stack.length) {\n      cur = stack.pop();\n      res.push(cur.val);\n      cur.right &amp;&amp; stack.push(cur.right);\n      cur.left &amp;&amp; stack.push(cur.left);\n    }\n    return res;\n  };\n  // ---前序遍历--- 中左右  压入栈右-&gt;左-&gt;中; 出栈 中-&gt;左-&gt;右\n  // const preOrderTraversal = (root) =&gt; {\n  //   let res = [],\n  //     stack = [root];\n  //   while (stack.length) {\n  //     const node = stack.pop();\n  //     if (!node) {\n  //       res.push(stack.pop().val);\n  //       continue;\n  //     }\n  //     node.right &amp;&amp; stack.push(node.right); // 右\n  //     node.left &amp;&amp; stack.push(node.left); // 左\n  //     stack.push(node); // 中\n  //     stack.push(null);\n  //   }\n  //   return res;\n  // };\n\n  // ---中序遍历---: (左中右) 入栈 左 -&gt; 右;  出栈 左 -&gt; 中 -&gt; 右\n  const inOrderTraversal = (root) =&gt; {\n    if (!root) return [];\n    let res = [],\n      stack = [],\n      cur = root;\n    do {\n      if (cur) {\n        stack.push(cur);\n        cur = cur.left;\n      } else {\n        cur = stack.pop();\n        res.push(cur.val);\n        cur = cur.right;\n      }\n    } while (stack.length || cur);\n    return res;\n  };\n\n  // ---后序遍历---: (左右中) 栈进入顺序 左 -&gt; 右;  出栈  中 -&gt; 右 -&gt; 左 结果翻转\n  const postOrderTraversal = (root) =&gt; {\n    let res = [];\n    if (!root) return res;\n    let stack = [root],\n      cur = null;\n    while (stack.length) {\n      cur = stack.pop();\n      res.push(cur.val);\n      cur.left &amp;&amp; stack.push(cur.left);\n      cur.right &amp;&amp; stack.push(cur.right);\n    }\n    return res.reverse();\n  };\n  // ---后续遍历--- 左右中\n  // const postOrderTraversal_2 = (root) =&gt; {\n  //   let res = [];\n  //   if (!root) return res;\n  //   let stack = [root],\n  //     visited = new Set();\n\n  //   while (stack.length) {\n  //     const node = stack[stack.length - 1];\n  //     if (node.left &amp;&amp; !visited.has(node.left)) {\n  //       stack.push(node.left);\n  //     } else if (node.right &amp;&amp; !visited.has(node.right)) {\n  //       stack.push(node.right);\n  //     } else {\n  //       res.push(node.val);\n  //       visited.add(node);\n  //       stack.pop();\n  //     }\n  //   }\n  //   return res;\n  // };\n};\n\n// 示例二叉树结构\nclass TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\nroot.right.left = new TreeNode(6);\nroot.right.right = new TreeNode(7);\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 测试前序遍历方法</p>\n<p>// 102.二叉树的层序遍历次  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const levelOrder = (root) =&gt; {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let curLevel = [],\n      len = queue.length;\n    for (let i = 0; i &lt; len; i++) {\n      const node = queue.shift();\n      curLevel.push(node.val);\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n    // res.push(curLevel);\n    res.unshift(curLevel);\n  }\n  return res;\n};\n// 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\nconst levelOrderBottom = (root) =&gt; {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let curLevel = [],\n      len = queue.length;\n    while (len--) {\n      const node = queue.shift();\n      curLevel.push(node.val);\n      // 把下一层级的左右节点存入queue队列\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n    res.unshift(curLevel);\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 199.二叉树的右视图 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>class TreeNode {\n  constructor(val, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nconst root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\nroot.right.left = new TreeNode(6);\nroot.right.right = new TreeNode(7);\n\nconst rightSideView = (root) =&gt; {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let len = queue.length;\n    while (len--) {\n      const node = queue.shift();\n      if (!len) {\n        res.push(node.val);\n      }\n      // 把下一层级的左右节点存入queue队列\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n  }\n  return res;\n};\nconsole.log(&quot;rightSideView(root): &quot;, rightSideView(root));\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 637.二叉树的层平均值  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const averageOfLevels = (root) =&gt; {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let sum = 0,\n      curLen = queue.length,\n      len = curLen;\n    while (len--) {\n      const node = queue.shift();\n      sum += node.val;\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n    res.push(sum / curLen);\n  }\n  return res;\n};\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>/**</p>\n<ul>\n<li>\n<ol>\n<li>广度优先搜索（BFS）需要先进先出（FIFO）的队列行为，以确保节点按层次顺序被处理。这就是为什么 shift() 被用于 BFS 的原因</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>如果使用 pop()，队列将变成后进先出（LIFO）的行为，这是深度优先搜索（DFS）的特性，而不是广度优先搜索。\n*/</li>\n</ol>\n</li>\n</ul>\n<p>// 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const levelOrderN = function (root) {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let len = queue.length,\n      curLevel = [];\n    while (len--) {\n      const node = queue.shift();\n      curLevel.push(node.val);\n      for (let item of node.children) {\n        item &amp;&amp; queue.push(item);\n      }\n    }\n    res.push(curLevel);\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 515. 在每个树行中找最大值 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const largestValues = function (root) {\n  if (!root) return [];\n  let res = [],\n    queue = [root];\n  while (queue.length) {\n    let len = queue.length,\n      max = -Infinity;\n    while (len--) {\n      const node = queue.shift();\n      max = Math.max(max, node.val);\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n    res.push(max);\n  }\n  return res;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 116.填充每个节点的下一个右侧节点指针\n/**</p>\n<ul>\n<li>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\nstruct Node {\nint val;\nNode *left;\nNode *right;\nNode *next;\n}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。\n*/</li>\n</ul>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const connect = function (root) {\n if (!root) return root;\n let queue = [root];\n while (queue.length) {\n   let len = queue.length;\n   while (len--) {\n     const node = queue.shift();\n     if (len &gt; 0) {\n       node.next = queue[0];\n     }\n     node.left &amp;&amp; queue.push(node.left);\n     node.right &amp;&amp; queue.push(node.right);\n   }\n }\n return root;\n};\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const maxDepth = function (root) {\n  let max = 0\n  if (!root) return max;\n  let queue = [root];\n  while (queue.length) {\n    let len = queue.length;\n    max++\n    while (len--) {\n      const node = queue.shift();\n      node.left &amp;&amp; queue.push(node.left);\n      node.right &amp;&amp; queue.push(node.right);\n    }\n  }\n  return max;\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 111.二叉树的最小深度</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>const minDepth = function(root) {\n  let min = 0,queue = [root]\n  if (!root) return min\n  while(queue.length) {\n    let len = queue.length\n    min++\n    while(len--) {\n      const node = queue.shift()\n      if (!node.left &amp;&amp; !node.right) return min\n      node.left &amp;&amp; queue.push(node.left)\n      node.right &amp;&amp; queue.push(node.right)\n    }\n  }\n  return min\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>// 翻转二叉树\n// 递归</p>\n<!--beforebegin--><div class=\"language- extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var invertTree = function(root) {\n  if(root == null) return root\n  const rightNode = root.right\n  root.right = invertTree(root.left)\n  root.left = invertTree(rightNode)\n  return root\n}\n\n// 层序遍历\nvar invertTree2 = function(root) {\n  const invertNode = (root, left, right) =&gt; {\n    const temp = left\n    root.left = right\n    root.right = temp\n  }\n  if (root == null) return root\n  let queue = [root]\n  while(queue.length) {\n    let len = queue.length\n    if (len--) {\n      const node = queue.shift()\n      invertNode(node, node.left, node.right)\n      node.left &amp;&amp; queue.push(node.left)\n      node.right &amp;&amp; queue.push(node.right)\n    }\n  }\n  return root\n}\n// 迭代遍历 (前序遍历中左右); 入栈顺序为：右左 (栈是后进先出原则)\nvar invertTree3 = function(root) {\n  if (root == null) return root\n  let queue = [root]\n  while (queue.length) {\n    let curNode = queue.pop()\n    const temp = curNode.left\n    curNode.left = curNode.right\n    curNode.right = temp\n\n    // 将右子节点入栈\n    if (curNode.right) queue.push(curNode.right)\n\n    // 将右子节点入栈\n    if (curNode.left) queue.push(curNode.left)\n  }\n  return root\n}\n</code></pre>\n<!--beforeend--></div><!--afterend--></div>\n",null]}