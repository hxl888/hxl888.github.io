{"remainingRequest":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js??ref--3-0!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/babel-loader/lib/index.js??ref--3-1!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??ref--6!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/backstage/node.md?vue&type=template&id=2846502e","dependencies":[{"path":"/Users/mypro/history/gitpro/hxl888.github.io/docs/pages/backstage/node.md","mtime":1723100283623},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/babel-loader/lib/index.js","mtime":1723084153686},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1723084153564},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vue-loader/lib/index.js","mtime":1718962895631},{"path":"/Users/mypro/history/gitpro/hxl888.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1723084153489}],"contextDependencies":[],"result":["var render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c('div', {\n    staticClass: \"content\"\n  }, [_vm._ssrNode(\"<h1 id=\\\"nodejs笔记\\\"><a href=\\\"#nodejs笔记\\\" class=\\\"header-anchor\\\">#</a> nodejs笔记</h1><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const express = require('express');\\nconst bodyParser = require('body-parser'); // 中间件（只能解析普通的post数据不能解析上传文件数据）\\nget - 无需中间件\\nreq.query\\npost - 需要body-parser\\nserver.use(bodyParser.urlencoded({\\n    extended: false, // 扩展模式\\n    limit: 2*1024 // 限制2M\\n}));\\nserver.use(function(req, res){\\n    console.log(res.body);\\n});\\n</code></pre></div><h3 id=\\\"链式操作\\\"><a href=\\\"#链式操作\\\" class=\\\"header-anchor\\\">#</a> 链式操作</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>server.use('/', function(req,res,next){\\n    console.log(a);\\n    next();\\n})\\nserver.use('/', function(req,res,next){\\n    console.log(b);\\n})\\n</code></pre></div><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>server.use(function(req, res, next){\\n    req.body = { };\\n })\\n</code></pre></div><h3 id=\\\"cookie-cookie-session\\\"><a href=\\\"#cookie-cookie-session\\\" class=\\\"header-anchor\\\">#</a> cookie / cookie-session</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>// cookie\\nconst cookieParser = require('cookie-parser');\\nserver.use(cookieParser('sfjlfjls3')); // 签名\\nserver.uer('/', function(){\\n    req.secret='sfjlfjls3'; // 后台签名 cookieParser('sfjlfjls3')写完之后此处可以不写\\n    res.cookie('user', 'blue', {signed: true, path: '', maxAge: ''}); // 签名\\n    \\n    res.clearCookie('user'); // 删除cookie\\n    console.log('无签名cookie', req.cookies); \\n    console.log('签名cookie', req.singnedCookies);\\n    res.send('ok');\\n});\\nserver.listen(8080);\\n\\ncookie加密 cookie-encrypter \\n\\n// cookie-session 存在于服务器 不能独立存在，基于cookie\\nconst cookieParser = require('cookie-parser');\\nconst cookieSession = require('cookie-session');\\nserver.use(cookieParser());\\nserver.use(cookieSession({\\n    name: 'sess', // 名字随便定义\\n    keys: ['aa', 'bb', 'cc']，// 数组越长越安全\\n    maxAge: 2*3600*1000 // 例如两个小时\\n}));\\nserver.uer('/', function(){\\n    if (req.sesion['count' == nll]) {\\n        req.session['count'] = 1;\\n    } else {\\n        req.session['count']++;\\n    }\\n    delete req.session['count']; // 删除session\\n    console.log(req.session['count']);\\n    console.log(req.session);\\n    res.send('ok'); \\n});\\n\\n\\n</code></pre></div><h3 id=\\\"nodejs模板引擎\\\"><a href=\\\"#nodejs模板引擎\\\" class=\\\"header-anchor\\\">#</a> nodejs模板引擎</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>两个主流模板：\\njade - 破坏式、侵入式、强依赖\\nejs  - 温和非侵入式、若依赖\\n\\n\\n=============jade=================\\n可以识别单双标签！\\n1.根据缩进规定层级；\\n2.属性放在括号里逗号分隔: \\n       例如:script(src='a.js') \\n            link(href='a.css', ref='')\\n            input(type='text', id ='', value='')\\n            a(href='www.baidu.com') 链接名\\n            \\n3.内联样式: div(style='width:200px;height:100px') 或\\n            div(style={width: '200px', height: '100px'}) // json只试用style属性的才能用json\\n            \\n4.class名:  div(class='aa bb cc')或\\n            div(class=['aa', 'bb', 'cc'])\\n            div.class\\n            ***title不能用数组***\\n            \\n5.id名:     div#id\\n            div&amp;attributes({title: '', id: ''}); // 加上'&amp;\\n            '符号才可以用json写上title\\n             \\n\\nconst jade = require('jade');\\n // var str = jade.render('html');\\n var str = jade.renderFile('./view/1.jade', {pretty: true});\\n // pretty 美化输入的html\\nconsole.log(str);\\n\\n=============ejs=================\\nconst ejs = require('ejs');\\nejs.renderFile('./view/1.ejs', {}, function(err, data){\\n    if (err) {\\n        console.log('编译失败');\\n    } else {\\n        console.log(data);\\n    }\\n});\\n</code></pre></div><h3 id=\\\"ejs\\\"><a href=\\\"#ejs\\\" class=\\\"header-anchor\\\">#</a> ejs</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const ejs = require('ejs');\\nejs.renderFile('.view/1.ejs',{}, function(err, data){\\n    console.log(data);\\n})\\nejs模板输入形式\\n&lt;%= 变量名 吧%&gt;\\n&lt;%  var str = '&lt;div&gt;&lt;/div&gt;'; %&gt;\\n\\n&lt;%- str %&gt; // '-'号为不转义输入 ；'='为为转义输入；\\n&lt;% include ./a.txt %&gt; // 引入文件\\n\\n=====include写法====\\n\\n&lt;% if(type == 'admin') {%&gt;\\n&lt;% include ../style/admin.css %&gt;\\n&lt;%} else {%&gt;\\n&lt;% include ../style/user.css %&gt;\\n&lt;% } %&gt;\\n\\n</code></pre></div><h3 id=\\\"实践区\\\"><a href=\\\"#实践区\\\" class=\\\"header-anchor\\\">#</a> 实践区</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>enctype='multipart/form-data' // 处理文件上传用的\\n&lt;form enctype='multipart/form-data' methods='post'&gt;\\n    &lt;input type='file' /&gt;\\n&lt;/form&gt;\\n\\n需要用到npm模块 multer(处理multipart/form-data表单)!\\n\\nconst pathLib = require('path');\\nconst bodyParser = require('body-parser');\\ncosnt fs = require('fs');\\nconst multer = require('multer'); // 解析post文件\\n\\n\\nserver.use(multer({dest: './www/unpload/'}).any());  \\nserver.use(bodyParse.urlencode(({extended: false}));\\n******\\nbody-parser 解析post数据 application/x-www-form-urlencoded\\n用法: \\nmulter       解析post文件 multipart/form-data\\n\\n******\\n\\nmulter用法如下:\\nserver.use(multer().any());         // 任何文件上传\\nserver.use(multer().single('f1'));  // 指定文件上传\\n\\n--------------------------------------\\nserver.post('/', function(req, res){\\n    console.log(req.files); // 上传文件信息\\n});\\nserver.use(function(req, res){\\n    req.files[0].originalname\\n    req.files[0].path\\n});\\n给文件加上扩展名==》\\nvar newName = file.path + pathLib.parse(file.originalname).ext;\\n});\\n---------------------------------------\\n\\n</code></pre></div><h3 id=\\\"consolidate-适配模板引擎-ejs、jade\\\"><a href=\\\"#consolidate-适配模板引擎-ejs、jade\\\" class=\\\"header-anchor\\\">#</a> consolidate-适配模板引擎(ejs、jade...)</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const consolidate = require('consolidate');\\n1.用的哪种模板引擎 2.模板引擎放哪了 3.输入什么东西\\n全局配置\\nserver.set('view engine', 'html');      // 输入什么东西\\nserver.set('views', './views');         // 模板引擎放哪了\\nserver.engine('html', consolodata.ejs); // 用的哪种模板引擎\\n\\nserver.get('/', function(){\\n    if (req.session.userid){            // 登录过\\n        res.render('1.ejs', {name: 'blue'));\\n        render()                        // 编译模板\\n        send()                          // 直接返回\\n    } else {                            // 没有登录\\n        res.render('login.ejs', {});\\n    }\\n});\\n\\n</code></pre></div><h3 id=\\\"node路由\\\"><a href=\\\"#node路由\\\" class=\\\"header-anchor\\\">#</a> node路由</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const express = require('express');\\nvar server = express();\\nvar routeUser = express.Router();\\nrouteUser.get('/1.html', function(req, res){\\n    res.send('user1');\\n};\\nserver.use('/user', routerUser);\\nserver.listen(8000);\\n \\n</code></pre></div><h3 id=\\\"数据-数据库\\\"><a href=\\\"#数据-数据库\\\" class=\\\"header-anchor\\\">#</a><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>数据-数据库</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em></h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>关系型:\\nMYSQL、Oracle、SQLServer、Access、db2、fox、pro\\n\\nMySQL:\\n免费、中小网站\\n优点: 性能非常不错\\n确定: 集群、容灾稍微弱一些\\n\\nOracle:\\n挺贵、大型应用、金融级\\n优点: 性能非常不错、集群、容灾非常强\\n确定: 挺贵\\n\\n\\n文件型:\\nsqlite、mongodb\\n\\n空间型:\\n\\n==================\\nserver端:\\n数据存在\\n\\nclinent端:\\n管理工具、Node\\n==================\\n\\n数据基本概念:\\n两种单位: \\n1.库: 文件夹-用来管理,本身没法存数据\\n2.表: 文件  -存数据的\\n主键：唯一、性能高、唯一标识符\\n\\n</code></pre></div><h3 id=\\\"mysql数据库连接\\\"><a href=\\\"#mysql数据库连接\\\" class=\\\"header-anchor\\\">#</a> mysql数据库连接</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const mysql = require('mysql');\\nvar db = mysql.createConnection({\\n    host: 'localhost',\\n    user: 'root',\\n    password: '123456',\\n    database: '数据库名字'\\n});\\nconsole.log(db);\\n\\n2.查询\\ndb.query('mysql查询语句',function(err, data){\\n    console.log(data);\\n});\\n3.SQL: 查询语句\\n1.关键字大写;\\n2.库、表、字段需要加上反单引号``;\\n\\n增: INSERT INTO 表 (字段列表) VALUES(值列表)\\n    INSERT INTO user_table (ID, username, password) VALUES(0, 'blue', '123456');\\n删: DELETE FROM 表 WHERE 条件\\n改: UPDATE 表 SET 字段=值，字段，。。。 WHERE 条件\\n查: SELECT * FROM 表 WHERE 条件\\n\\n=============================================\\n#### 字句!!!: \\n\\n1.WHERE: 条件\\nSHERE name='blue'\\nWHERE age&gt;13\\nWHERE age&lt;=18\\nWHERE age&gt;=18 AND score&lt;60 (例如:大于18岁小于60分的同学。。。)\\nWHERE cach&gt;100 OR score&gt;10000\\n\\n**********\\n\\n2.ORDER: 排序--多条件排序\\nORDER BY age ASC/DESC  (ASC:升序，DESC:降序)\\nORDER BY price EDSC (价格降序排列)\\n*价格（price）升序排序，如果价格相同，再按销量（sales）降序排序\\nORDER BY price ASC, sales DESC   (中间加逗号，如果前一个没有排序成功就按着后面的条件进行排序)\\n\\n**********\\n\\n3.GROUP 聚类-合并相同的 COUNT 、MIN、MAX、AVG\\n*统计每个班人数\\nID class  name  ---》表结构(student_table)\\nCOUNT:计数\\nSELECT COUNT(*) FROM student_table; （总计人数）\\nSELECT * FROM student_table GROUP BY class;(以班级作为组划分人数 class为班级, 只会打印出来前排的去重班级之后的的几个人)\\nSELECT class FROM student_table GROUP BY class;(只会打印出来对应的班级去重重班级之后之后的对应班级号)\\nSELECT class,COUNT(class) FROM student_table GROUP BY class;(只会打印出来对应班级相同的次数 class：班级名，COUNT(class): 数字)；\\n\\n**********\\n\\nSELECT * FROM student_table;\\nSELECT * FROM stuednt_table BY class;\\nSELECT class,AVG(score) FROM student_table GROUP BY class;(统计每个班的平均分)\\nSELECT class,MAX(score),MIN(score) FROM student_table GROUP BY class;(每个班级的最高、最低分)\\nSELECT name,SUM(price) FROM sales_table GROUP BY name ORDER BY SUM(price) DESC;(每个人的消费总额)\\n\\n4.LINIMT 分页（比如每页20条数据的话）\\n第一页: 0，20 \\n第二页: 20,20\\n第三页: 40,20\\n第四页: 60,20\\n第n页: (n-1)*20,20\\n\\n**子句间是用顺序的*:***\\nWHERE GROUP ORDER LIMINT\\n\\nSELECT class,COUNT(class) FROM student_table \\nWHERE score&gt;60 \\nGROUP BY class \\nORDER BY COUNT(class) DESC \\nLIMIT 2;(按班级里分数大于60分并且合并班级里大于60的人数，所有班级大于60人数多少进行降序排序，只请求2条数据每页)\\n\\n</code></pre></div><h1 id=\\\"nodejs微信开发\\\"><a href=\\\"#nodejs微信开发\\\" class=\\\"header-anchor\\\">#</a> nodejs微信开发=======</h1><h3 id=\\\"ngrok-使外界能够访问本地的方法\\\"><a href=\\\"#ngrok-使外界能够访问本地的方法\\\" class=\\\"header-anchor\\\">#</a> ngrok 使外界能够访问本地的方法</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>1.ngrok\\n2.nodejs 的 localtunnel服务\\nnpm install -g localt unnel\\nlt --port 8000\\n\\n3.PageKite 花生壳\\n</code></pre></div><h3 id=\\\"项目开始start\\\"><a href=\\\"#项目开始start\\\" class=\\\"header-anchor\\\">#</a> 项目开始start</h3><h5 id=\\\"微信订阅号、服务号、企业号的区别：\\\"><a href=\\\"#微信订阅号、服务号、企业号的区别：\\\" class=\\\"header-anchor\\\">#</a> 微信订阅号、服务号、企业号的区别：</h5><p><img src=\\\"https://note.youdao.com/yws/api/personal/file/WEB16c29c3c8deaca2f4c45d289ceb31581?method=download&shareKey=e30488846939d7e7765868fc606ccf8b\\\" alt=\\\"微信测试号管理\\\"></p><p><img src=\\\"https://note.youdao.com/yws/api/personal/file/WEBc2f4c0e449a1889b0b5b07c03528b26a?method=download&shareKey=dd2d178d3076db2a80b107902b9cded5\\\" alt=\\\"微信测试号管理\\\"></p><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>运用koa起服务:\\n执行koa时需要在 —-harmony 模式下运行\\nnode --harmony app.js\\nvar Koa = require('koa');\\nvar sha1 = require('sha1');\\nvar config = {\\n    wechat: {\\n        appId: 'wx8d708ba3274d56f4',\\n        appsecret: '611fb2aa0b9ace244c13582337fa75cb',\\n        token: 'asdfsdfsdfsdffsfgrgf'\\n    }\\n};\\nvar app = new Koa();\\napp.use(function *(next) {\\n    console.log('---&gt;', this.query);\\n    var token = config.wechat.token;\\n    var timestamp = this.query.timestamp;\\n    var nonce = this.query.nonce;\\n    \\n    var signature = this.query.signature;\\n    var echostr = this.query.echostr;\\n    var str = [token, timestamp, nonce].sort().join('');\\n    var sha = sha1(str);\\n    if (sha === signature) {\\n        this.body = echostr + ''\\n    } else {\\n        this.body = 'wrong';\\n    }\\n});\\n\\napp.listen(1234);\\nconsole.log('listening: 1234');\\n\\n</code></pre></div><h3 id=\\\"localtunnel优缺点\\\"><a href=\\\"#localtunnel优缺点\\\" class=\\\"header-anchor\\\">#</a> localtunnel优缺点</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>localtunnel的缺点有:\\n1.不支持自定义域名映射\\n2.映射以后，一旦本机服务终止，再重启以后，会失去这个映射链接\\n\\n解决办法:\\n    在一台vpn上搭建一个自己的映射代理通道，这个开发难度比较大\\n    \\n替代方案:\\n    1.utralhook的服务：http://www.ultrahook.com/\\n    2.下载qq浏览器，在qq浏览器中有配套的解决方案\\n</code></pre></div>\")]);\n};\n\nvar staticRenderFns = [];\nexport { render, staticRenderFns };",{"version":3,"sources":["docs/pages/backstage/node.md"],"names":["render","_vm","_c","_self","staticClass","_ssrNode","staticRenderFns"],"mappings":"AAAA,IAAIA,SAAS,SAASA,MAAT,GAAiB;AAAC,MAAIC,MAAI,IAAR;AAAA,MAAaC,KAAGD,IAAIE,KAAJ,CAAUD,EAA1B;;AAA6B,SAAOA,GAAG,KAAH,EAAS;AAACE,iBAAY;AAAb,GAAT,EAAiC,CAACH,IAAII,QAAJ,CAAa,siXAAb,CAAD,CAAjC,CAAP;AAC3D,CADD;;AAEA,IAAIC,kBAAkB,EAAtB;AAEA,SAASN,MAAT,EAAiBM,eAAjB","sourceRoot":"/Users/mypro/history/gitpro/hxl888.github.io","sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"nodejs笔记\\\"><a href=\\\"#nodejs笔记\\\" class=\\\"header-anchor\\\">#</a> nodejs笔记</h1><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const express = require('express');\\nconst bodyParser = require('body-parser'); // 中间件（只能解析普通的post数据不能解析上传文件数据）\\nget - 无需中间件\\nreq.query\\npost - 需要body-parser\\nserver.use(bodyParser.urlencoded({\\n    extended: false, // 扩展模式\\n    limit: 2*1024 // 限制2M\\n}));\\nserver.use(function(req, res){\\n    console.log(res.body);\\n});\\n</code></pre></div><h3 id=\\\"链式操作\\\"><a href=\\\"#链式操作\\\" class=\\\"header-anchor\\\">#</a> 链式操作</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>server.use('/', function(req,res,next){\\n    console.log(a);\\n    next();\\n})\\nserver.use('/', function(req,res,next){\\n    console.log(b);\\n})\\n</code></pre></div><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>server.use(function(req, res, next){\\n    req.body = { };\\n })\\n</code></pre></div><h3 id=\\\"cookie-cookie-session\\\"><a href=\\\"#cookie-cookie-session\\\" class=\\\"header-anchor\\\">#</a> cookie / cookie-session</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>// cookie\\nconst cookieParser = require('cookie-parser');\\nserver.use(cookieParser('sfjlfjls3')); // 签名\\nserver.uer('/', function(){\\n    req.secret='sfjlfjls3'; // 后台签名 cookieParser('sfjlfjls3')写完之后此处可以不写\\n    res.cookie('user', 'blue', {signed: true, path: '', maxAge: ''}); // 签名\\n    \\n    res.clearCookie('user'); // 删除cookie\\n    console.log('无签名cookie', req.cookies); \\n    console.log('签名cookie', req.singnedCookies);\\n    res.send('ok');\\n});\\nserver.listen(8080);\\n\\ncookie加密 cookie-encrypter \\n\\n// cookie-session 存在于服务器 不能独立存在，基于cookie\\nconst cookieParser = require('cookie-parser');\\nconst cookieSession = require('cookie-session');\\nserver.use(cookieParser());\\nserver.use(cookieSession({\\n    name: 'sess', // 名字随便定义\\n    keys: ['aa', 'bb', 'cc']，// 数组越长越安全\\n    maxAge: 2*3600*1000 // 例如两个小时\\n}));\\nserver.uer('/', function(){\\n    if (req.sesion['count' == nll]) {\\n        req.session['count'] = 1;\\n    } else {\\n        req.session['count']++;\\n    }\\n    delete req.session['count']; // 删除session\\n    console.log(req.session['count']);\\n    console.log(req.session);\\n    res.send('ok'); \\n});\\n\\n\\n</code></pre></div><h3 id=\\\"nodejs模板引擎\\\"><a href=\\\"#nodejs模板引擎\\\" class=\\\"header-anchor\\\">#</a> nodejs模板引擎</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>两个主流模板：\\njade - 破坏式、侵入式、强依赖\\nejs  - 温和非侵入式、若依赖\\n\\n\\n=============jade=================\\n可以识别单双标签！\\n1.根据缩进规定层级；\\n2.属性放在括号里逗号分隔: \\n       例如:script(src='a.js') \\n            link(href='a.css', ref='')\\n            input(type='text', id ='', value='')\\n            a(href='www.baidu.com') 链接名\\n            \\n3.内联样式: div(style='width:200px;height:100px') 或\\n            div(style={width: '200px', height: '100px'}) // json只试用style属性的才能用json\\n            \\n4.class名:  div(class='aa bb cc')或\\n            div(class=['aa', 'bb', 'cc'])\\n            div.class\\n            ***title不能用数组***\\n            \\n5.id名:     div#id\\n            div&amp;attributes({title: '', id: ''}); // 加上'&amp;\\n            '符号才可以用json写上title\\n             \\n\\nconst jade = require('jade');\\n // var str = jade.render('html');\\n var str = jade.renderFile('./view/1.jade', {pretty: true});\\n // pretty 美化输入的html\\nconsole.log(str);\\n\\n=============ejs=================\\nconst ejs = require('ejs');\\nejs.renderFile('./view/1.ejs', {}, function(err, data){\\n    if (err) {\\n        console.log('编译失败');\\n    } else {\\n        console.log(data);\\n    }\\n});\\n</code></pre></div><h3 id=\\\"ejs\\\"><a href=\\\"#ejs\\\" class=\\\"header-anchor\\\">#</a> ejs</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const ejs = require('ejs');\\nejs.renderFile('.view/1.ejs',{}, function(err, data){\\n    console.log(data);\\n})\\nejs模板输入形式\\n&lt;%= 变量名 吧%&gt;\\n&lt;%  var str = '&lt;div&gt;&lt;/div&gt;'; %&gt;\\n\\n&lt;%- str %&gt; // '-'号为不转义输入 ；'='为为转义输入；\\n&lt;% include ./a.txt %&gt; // 引入文件\\n\\n=====include写法====\\n\\n&lt;% if(type == 'admin') {%&gt;\\n&lt;% include ../style/admin.css %&gt;\\n&lt;%} else {%&gt;\\n&lt;% include ../style/user.css %&gt;\\n&lt;% } %&gt;\\n\\n</code></pre></div><h3 id=\\\"实践区\\\"><a href=\\\"#实践区\\\" class=\\\"header-anchor\\\">#</a> 实践区</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>enctype='multipart/form-data' // 处理文件上传用的\\n&lt;form enctype='multipart/form-data' methods='post'&gt;\\n    &lt;input type='file' /&gt;\\n&lt;/form&gt;\\n\\n需要用到npm模块 multer(处理multipart/form-data表单)!\\n\\nconst pathLib = require('path');\\nconst bodyParser = require('body-parser');\\ncosnt fs = require('fs');\\nconst multer = require('multer'); // 解析post文件\\n\\n\\nserver.use(multer({dest: './www/unpload/'}).any());  \\nserver.use(bodyParse.urlencode(({extended: false}));\\n******\\nbody-parser 解析post数据 application/x-www-form-urlencoded\\n用法: \\nmulter       解析post文件 multipart/form-data\\n\\n******\\n\\nmulter用法如下:\\nserver.use(multer().any());         // 任何文件上传\\nserver.use(multer().single('f1'));  // 指定文件上传\\n\\n--------------------------------------\\nserver.post('/', function(req, res){\\n    console.log(req.files); // 上传文件信息\\n});\\nserver.use(function(req, res){\\n    req.files[0].originalname\\n    req.files[0].path\\n});\\n给文件加上扩展名==》\\nvar newName = file.path + pathLib.parse(file.originalname).ext;\\n});\\n---------------------------------------\\n\\n</code></pre></div><h3 id=\\\"consolidate-适配模板引擎-ejs、jade\\\"><a href=\\\"#consolidate-适配模板引擎-ejs、jade\\\" class=\\\"header-anchor\\\">#</a> consolidate-适配模板引擎(ejs、jade...)</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const consolidate = require('consolidate');\\n1.用的哪种模板引擎 2.模板引擎放哪了 3.输入什么东西\\n全局配置\\nserver.set('view engine', 'html');      // 输入什么东西\\nserver.set('views', './views');         // 模板引擎放哪了\\nserver.engine('html', consolodata.ejs); // 用的哪种模板引擎\\n\\nserver.get('/', function(){\\n    if (req.session.userid){            // 登录过\\n        res.render('1.ejs', {name: 'blue'));\\n        render()                        // 编译模板\\n        send()                          // 直接返回\\n    } else {                            // 没有登录\\n        res.render('login.ejs', {});\\n    }\\n});\\n\\n</code></pre></div><h3 id=\\\"node路由\\\"><a href=\\\"#node路由\\\" class=\\\"header-anchor\\\">#</a> node路由</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const express = require('express');\\nvar server = express();\\nvar routeUser = express.Router();\\nrouteUser.get('/1.html', function(req, res){\\n    res.send('user1');\\n};\\nserver.use('/user', routerUser);\\nserver.listen(8000);\\n \\n</code></pre></div><h3 id=\\\"数据-数据库\\\"><a href=\\\"#数据-数据库\\\" class=\\\"header-anchor\\\">#</a><em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>数据-数据库</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em></h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>关系型:\\nMYSQL、Oracle、SQLServer、Access、db2、fox、pro\\n\\nMySQL:\\n免费、中小网站\\n优点: 性能非常不错\\n确定: 集群、容灾稍微弱一些\\n\\nOracle:\\n挺贵、大型应用、金融级\\n优点: 性能非常不错、集群、容灾非常强\\n确定: 挺贵\\n\\n\\n文件型:\\nsqlite、mongodb\\n\\n空间型:\\n\\n==================\\nserver端:\\n数据存在\\n\\nclinent端:\\n管理工具、Node\\n==================\\n\\n数据基本概念:\\n两种单位: \\n1.库: 文件夹-用来管理,本身没法存数据\\n2.表: 文件  -存数据的\\n主键：唯一、性能高、唯一标识符\\n\\n</code></pre></div><h3 id=\\\"mysql数据库连接\\\"><a href=\\\"#mysql数据库连接\\\" class=\\\"header-anchor\\\">#</a> mysql数据库连接</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>const mysql = require('mysql');\\nvar db = mysql.createConnection({\\n    host: 'localhost',\\n    user: 'root',\\n    password: '123456',\\n    database: '数据库名字'\\n});\\nconsole.log(db);\\n\\n2.查询\\ndb.query('mysql查询语句',function(err, data){\\n    console.log(data);\\n});\\n3.SQL: 查询语句\\n1.关键字大写;\\n2.库、表、字段需要加上反单引号``;\\n\\n增: INSERT INTO 表 (字段列表) VALUES(值列表)\\n    INSERT INTO user_table (ID, username, password) VALUES(0, 'blue', '123456');\\n删: DELETE FROM 表 WHERE 条件\\n改: UPDATE 表 SET 字段=值，字段，。。。 WHERE 条件\\n查: SELECT * FROM 表 WHERE 条件\\n\\n=============================================\\n#### 字句!!!: \\n\\n1.WHERE: 条件\\nSHERE name='blue'\\nWHERE age&gt;13\\nWHERE age&lt;=18\\nWHERE age&gt;=18 AND score&lt;60 (例如:大于18岁小于60分的同学。。。)\\nWHERE cach&gt;100 OR score&gt;10000\\n\\n**********\\n\\n2.ORDER: 排序--多条件排序\\nORDER BY age ASC/DESC  (ASC:升序，DESC:降序)\\nORDER BY price EDSC (价格降序排列)\\n*价格（price）升序排序，如果价格相同，再按销量（sales）降序排序\\nORDER BY price ASC, sales DESC   (中间加逗号，如果前一个没有排序成功就按着后面的条件进行排序)\\n\\n**********\\n\\n3.GROUP 聚类-合并相同的 COUNT 、MIN、MAX、AVG\\n*统计每个班人数\\nID class  name  ---》表结构(student_table)\\nCOUNT:计数\\nSELECT COUNT(*) FROM student_table; （总计人数）\\nSELECT * FROM student_table GROUP BY class;(以班级作为组划分人数 class为班级, 只会打印出来前排的去重班级之后的的几个人)\\nSELECT class FROM student_table GROUP BY class;(只会打印出来对应的班级去重重班级之后之后的对应班级号)\\nSELECT class,COUNT(class) FROM student_table GROUP BY class;(只会打印出来对应班级相同的次数 class：班级名，COUNT(class): 数字)；\\n\\n**********\\n\\nSELECT * FROM student_table;\\nSELECT * FROM stuednt_table BY class;\\nSELECT class,AVG(score) FROM student_table GROUP BY class;(统计每个班的平均分)\\nSELECT class,MAX(score),MIN(score) FROM student_table GROUP BY class;(每个班级的最高、最低分)\\nSELECT name,SUM(price) FROM sales_table GROUP BY name ORDER BY SUM(price) DESC;(每个人的消费总额)\\n\\n4.LINIMT 分页（比如每页20条数据的话）\\n第一页: 0，20 \\n第二页: 20,20\\n第三页: 40,20\\n第四页: 60,20\\n第n页: (n-1)*20,20\\n\\n**子句间是用顺序的*:***\\nWHERE GROUP ORDER LIMINT\\n\\nSELECT class,COUNT(class) FROM student_table \\nWHERE score&gt;60 \\nGROUP BY class \\nORDER BY COUNT(class) DESC \\nLIMIT 2;(按班级里分数大于60分并且合并班级里大于60的人数，所有班级大于60人数多少进行降序排序，只请求2条数据每页)\\n\\n</code></pre></div><h1 id=\\\"nodejs微信开发\\\"><a href=\\\"#nodejs微信开发\\\" class=\\\"header-anchor\\\">#</a> nodejs微信开发=======</h1><h3 id=\\\"ngrok-使外界能够访问本地的方法\\\"><a href=\\\"#ngrok-使外界能够访问本地的方法\\\" class=\\\"header-anchor\\\">#</a> ngrok 使外界能够访问本地的方法</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>1.ngrok\\n2.nodejs 的 localtunnel服务\\nnpm install -g localt unnel\\nlt --port 8000\\n\\n3.PageKite 花生壳\\n</code></pre></div><h3 id=\\\"项目开始start\\\"><a href=\\\"#项目开始start\\\" class=\\\"header-anchor\\\">#</a> 项目开始start</h3><h5 id=\\\"微信订阅号、服务号、企业号的区别：\\\"><a href=\\\"#微信订阅号、服务号、企业号的区别：\\\" class=\\\"header-anchor\\\">#</a> 微信订阅号、服务号、企业号的区别：</h5><p><img src=\\\"https://note.youdao.com/yws/api/personal/file/WEB16c29c3c8deaca2f4c45d289ceb31581?method=download&shareKey=e30488846939d7e7765868fc606ccf8b\\\" alt=\\\"微信测试号管理\\\"></p><p><img src=\\\"https://note.youdao.com/yws/api/personal/file/WEBc2f4c0e449a1889b0b5b07c03528b26a?method=download&shareKey=dd2d178d3076db2a80b107902b9cded5\\\" alt=\\\"微信测试号管理\\\"></p><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>运用koa起服务:\\n执行koa时需要在 —-harmony 模式下运行\\nnode --harmony app.js\\nvar Koa = require('koa');\\nvar sha1 = require('sha1');\\nvar config = {\\n    wechat: {\\n        appId: 'wx8d708ba3274d56f4',\\n        appsecret: '611fb2aa0b9ace244c13582337fa75cb',\\n        token: 'asdfsdfsdfsdffsfgrgf'\\n    }\\n};\\nvar app = new Koa();\\napp.use(function *(next) {\\n    console.log('---&gt;', this.query);\\n    var token = config.wechat.token;\\n    var timestamp = this.query.timestamp;\\n    var nonce = this.query.nonce;\\n    \\n    var signature = this.query.signature;\\n    var echostr = this.query.echostr;\\n    var str = [token, timestamp, nonce].sort().join('');\\n    var sha = sha1(str);\\n    if (sha === signature) {\\n        this.body = echostr + ''\\n    } else {\\n        this.body = 'wrong';\\n    }\\n});\\n\\napp.listen(1234);\\nconsole.log('listening: 1234');\\n\\n</code></pre></div><h3 id=\\\"localtunnel优缺点\\\"><a href=\\\"#localtunnel优缺点\\\" class=\\\"header-anchor\\\">#</a> localtunnel优缺点</h3><div class=\\\"language- extra-class\\\"><pre class=\\\"language-text\\\"><code>localtunnel的缺点有:\\n1.不支持自定义域名映射\\n2.映射以后，一旦本机服务终止，再重启以后，会失去这个映射链接\\n\\n解决办法:\\n    在一台vpn上搭建一个自己的映射代理通道，这个开发难度比较大\\n    \\n替代方案:\\n    1.utralhook的服务：http://www.ultrahook.com/\\n    2.下载qq浏览器，在qq浏览器中有配套的解决方案\\n</code></pre></div>\")])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}]}