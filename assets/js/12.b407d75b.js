(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{152:function(n,e,a){"use strict";a.r(e);var t=a(0),r=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"nginx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx","aria-hidden":"true"}},[n._v("#")]),n._v(" nginx")]),a("h3",{attrs:{id:"nginx-的安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx-的安装","aria-hidden":"true"}},[n._v("#")]),n._v(" nginx 的安装")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("下载地址: http://nginx.org/download/nginx-1.4.2.tar.gz\n安装准备: nginx依赖于pcre库,要先安装pcre\nyum install pcre pcre-devel\n cd /usr/local/src/\n wget http://nginx.org/download/nginx-1.4.2.tar.gz\ntar zxvf nginx-1.4.2.tar.gz \ncd nginx-1.4.2\n./configure --prefix=/usr/local/nginx\nmake && make install\n\n")])])]),a("h3",{attrs:{id:"启动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启动","aria-hidden":"true"}},[n._v("#")]),n._v(" 启动:")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("cd /ulsr/local/nginx, 看到如下4个目录\n./\n ....conf 配置文件  \n ... html 网页文件\n ...logs  日志文件 \n ...sbin  主要二进制程序\n\n[root@localhost nginx]# ./sbin/nginx \nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n....\nnginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\nnginx: [emerg] still could not bind()\n\n")])])]),a("p",[n._v("不能绑定80端口,80端口已经被占用\n(有时是自己装了apache,nginx等,还有更多情况是操作系统自带了apache并作为服务启动)\n解决: 把占用80端口的软件或服务关闭即可.")]),a("h3",{attrs:{id:"nginx的信号控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx的信号控制","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx的信号控制")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TERM, INT\tQuick shutdown QUIT\tGraceful shutdown  优雅的关闭进程,即等请求结束后再关闭；\n\nHUP\tConfiguration reload ,Start the new worker processes with\n a new configuration Gracefully shutdown the old worker processes\n \n改变配置文件,平滑的重读配置文件:\n\nUSR1\tReopen the log files 重读日志,在日志按月/日分割时有用\n\nUSR2\tUpgrade Executable on the fly 平滑的升级\n\nWINCH\tGracefully shutdown the worker processes 优雅关闭旧的进程(配合USR2来进行升级)\n\n\n具体语法:\nKill -信号选项 nginx的主进程号\nKill -HUP 4873\n\nKill -信号控制 `cat /xxx/path/log/nginx.pid`\n\nKil; -USR1 `cat /xxx/path/log/nginx.pid`\n\n")])])]),a("h3",{attrs:{id:"nginx配置段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx配置段","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx配置段")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 全局区\nworker_processes 1; // 有1个工作的子进程,可以自行修改,但太大无益,因为要争夺CPU,一般设置为 CPU数*核数\n\nEvent {\n// 一般是配置nginx连接的特性\n// 如1个word能同时允许多少连接\n worker_connections  1024; // 这是指 一个子进程最大允许连1024个连接\n}\n\nhttp {  //这是配置http服务器的主要段\n     Server1 { // 这是虚拟主机段\n       \n            Location {  //定位,把特殊的路径或文件再次定位 ,如image目录单独处理\n            }             /// 如.php单独处理\n\n     }\n\n     Server2 {\n     }\n}\n\n\n例子1: 基于域名的虚拟主机\n\n    server {\n        listen 80;  #监听端口\n        server_name a.com; #监听域名\n\n        location / {\n                root /var/www/a.com;   #根目录定位\n                index index.html;\n        }\n    }\n\n例子2: 基于端口的虚拟主机配置\n\n    server {\n        listen 8080;\n        server_name 192.168.1.204;\n\n        location / {\n                root /var/www/html8080;\n                index index.html;\n        }\n    }\n日志管理\n\n\n我们观察nginx的server段,可以看到如下类似信息\n #access_log  logs/host.access.log  main;\n这说明 该server, 它的访问日志的文件是  logs/host.access.log ,\n使用的格式”main”格式.\n除了main格式,你可以自定义其他格式.\n\nmain格式是什么?\nlog_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n    #                  \'$status $body_bytes_sent "$http_referer" \'\n    #                  \'"$http_user_agent" "$http_x_forwarded_for"\';\n\nmain格式是我们定义好一种日志的格式,并起个名字,便于引用.\n以上面的例子, main类型的日志,记录的 remote_addr.... http_x_forwarded_for等选项.\n\n\n1: 日志格式 是指记录哪些选项\n默认的日志格式: main\n     log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                            \'$status $body_bytes_sent "$http_referer" \'\n                            \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n如默认的main日志格式,记录这么几项\n远程IP- 远程用户/用户时间 请求方法(如GET/POST) 请求体body长度 referer来源信息\nhttp-user-agent用户代理/蜘蛛 ,被转发的请求的原始IP\n\nhttp_x_forwarded_for:在经过代理时,代理把你的本来IP加在此头信息中,传输你的原始IP\n\n\n\n2: 声明一个独特的log_format并命名\n\n    log_format  mylog \'$remote_addr- "$request" \'\n                     \'$status $body_bytes_sent "$http_referer" \'\n                        \'"$http_user_agent" "$http_x_forwarded_for"\';\n在下面的server/location,我们就可以引用 mylog\n\n在server段中,这样来声明\nNginx允许针对不同的server做不同的Log ,(有的web服务器不支持,如lighttp)\n\naccess_log logs/access_8080.log mylog;   \n声明log   log位置          log格式;\n\n实际应用: shell+定时任务+nginx信号管理,完成日志按日期存储\n分析思路: \n凌晨00:00:01,把昨天的日志重命名,放在相应的目录下\n再USR1信息号控制nginx重新生成新的日志文件\n\n\n')])])]),a("h3",{attrs:{id:"具体脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具体脚本","aria-hidden":"true"}},[n._v("#")]),n._v(" 具体脚本:")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('#!/bin/bash\nbase_path=\'/usr/local/nginx/logs\'\nlog_path=$(date -d yesterday +"%Y%m")\nday=$(date -d yesterday +"%d")\nmkdir -p $base_path/$log_path\nmv $base_path/access.log $base_path/$log_path/access_$day.log\n#echo $base_path/$log_path/access_$day.log\nkill -USR1 `cat /usr/local/nginx/logs/nginx.pid`\n\n\n')])])]),a("h3",{attrs:{id:"定时任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时任务","aria-hidden":"true"}},[n._v("#")]),n._v(" 定时任务")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Crontab 编辑定时任务\n01 00 * * * /xxx/path/b.sh  每天0时1分(建议在02-04点之间,系统负载小)\n\n")])])]),a("h3",{attrs:{id:"location-语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-语法","aria-hidden":"true"}},[n._v("#")]),n._v(" location 语法")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("location 有”定位”的意思, 根据Uri来进行不同的定位.\n在虚拟主机的配置中,是必不可少的,location可以把网站的不同部分,定位到不同的处理方式上.\n比如, 碰到.php, 如何调用PHP解释器?  --这时就需要location\nlocation 的语法\nlocation [=|~|~*|^~] patt {\n}\n中括号可以不写任何参数,此时称为一般匹配\n也可以写参数\n因此,大类型可以分为3种\nlocation = patt {} [精准匹配]\nlocation patt{}  [一般匹配]\nlocation ~ patt{} [正则匹配]\n\n")])])]),a("h3",{attrs:{id:"如何发挥作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何发挥作用","aria-hidden":"true"}},[n._v("#")]),n._v(" 如何发挥作用?:")]),a("p",[n._v("首先看有没有精准匹配,如果有,则停止匹配过程.")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("location = patt {\n    config A\n}\n如果 $uri == patt,匹配成功，使用configA\n   location = / {\n              root   /var/www/html/;\n             index  index.htm index.html;\n        }\n         \n  location / {\n             root   /usr/local/nginx/html;\n            index  index.html index.htm;\n  }\n\n如果访问　　http://xxx.com/\n定位流程是　\n1: 精准匹配中　”/”   ,得到index页为　　index.htm\n2: 再次访问 /index.htm , 此次内部转跳uri已经是”/index.htm” , \n根目录为/usr/local/nginx/html\n3: 最终结果,访问了 /usr/local/nginx/html/index.htm\n\n再来看,正则也来参与.\nlocation / {\n            root   /usr/local/nginx/html;\n            index  index.html index.htm;\n        }\n\nlocation ~ image {\n           root /var/www/image;\n           index index.html;\n}\n\n如果我们访问  http://xx.com/image/logo.png\n此时, “/” 与”/image/logo.png” 匹配\n同时,”image”正则 与”image/logo.png”也能匹配,谁发挥作用?\n正则表达式的成果将会使用.\n\n图片真正会访问 /var/www/image/logo.png \n\nlocation / {\n             root   /usr/local/nginx/html;\n             index  index.html index.htm;\n         }\n \nlocation /foo {\n            root /var/www/html;\n             index index.html;\n}\n我们访问 http://xxx.com/foo\n 对于uri “/foo”,   两个location的patt,都能匹配他们\n即 ‘/’能从左前缀匹配 ‘/foo’, ‘/foo’也能左前缀匹配’/foo’,\n此时, 真正访问 /var/www/html/index.html \n原因:’/foo’匹配的更长,因此使用之.;\n\n")])])]),a("h3",{attrs:{id:"rewrite-重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rewrite-重写","aria-hidden":"true"}},[n._v("#")]),n._v(" rewrite 重写")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("重写中用到的指令\nif  (条件) {}  设定条件,再进行重写 \nset #设置变量\nreturn #返回状态码 \nbreak #跳出rewrite\nrewrite #重写\n\n\nIf  语法格式\nIf 空格 (条件) {\n    重写模式\n}\n\n条件又怎么写?\n答:3种写法\n1: “=”来判断相等, 用于字符串比较\n2: “~” 用正则来匹配(此处的正则区分大小写)\n   ~* 不区分大小写的正则\n3: -f -d -e来判断是否为文件,为目录,是否存在.\n\n例子:\n\n            if  ($remote_addr = 192.168.1.100) {\n                return 403;\n            }\n\n\n if ($http_user_agent ~ MSIE) {\n                rewrite ^.*$ /ie.htm;\n                break; #(不break会循环重定向)\n }\n\n             if (!-e $document_root$fastcgi_script_name) {\n                rewrite ^.*$ /404.html break;\n            } \n            注, 此处还要加break,\n以 xx.com/dsafsd.html这个不存在页面为例,\n我们观察访问日志, 日志中显示的访问路径,依然是GET /dsafsd.html HTTP/1.1\n提示: 服务器内部的rewrite和302跳转不一样. \n跳转的话URL都变了,变成重新http请求404.html, 而内部rewrite, 上下文没变,\n就是说 fastcgi_script_name 仍然是 dsafsd.html,因此 会循环重定向.\nset 是设置变量用的, 可以用来达到多条件判断时作标志用.\n达到apache下的 rewrite_condition的效果\n\n如下: 判断IE并重写,且不用break; 我们用set变量来达到目的\nif ($http_user_agent ~* msie) {\n                set $isie 1;\n            }\n\n            if ($fastcgi_script_name = ie.html) {\n                set $isie 0;\n            }\n\n            if ($isie 1) {\n                rewrite ^.*$ ie.html;\n            }\n\n\n")])])]),a("h3",{attrs:{id:"rewrite语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rewrite语法","aria-hidden":"true"}},[n._v("#")]),n._v(" Rewrite语法")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Rewrite 正则表达式  定向后的位置 模式\n\nGoods-3.html ----\x3eGoods.php?goods_id=3\ngoods-([\\d]+)\\.html ---\x3e goods.php?goods_id =$1  \n\nlocation /ecshop {\nindex index.php;\nrewrite goods-([\\d]+)\\.html$ /ecshop/goods.php?id=$1;\nrewrite article-([\\d]+)\\.html$ /ecshop/article.php?id=$1;\nrewrite category-(\\d+)-b(\\d+)\\.html /ecshop/category.php?id=$1&brand=$2;\n\nrewrite category-(\\d+)-b(\\d+)-min(\\d+)-max(\\d+)-attr([\\d\\.]+)\\.html /ecshop/category.php?id=$1&brand=$2&price_min=$3&price_max=$4&filter_attr=$5;\n\nrewrite category-(\\d+)-b(\\d+)-min(\\d+)-max(\\d+)-attr([\\d+\\.])-(\\d+)-([^-]+)-([^-]+)\\.html /ecshop/category.php?id=$1&brand=$2&price_min=$3&price_max=$4&filter_attr=$5&page=$6&sort=$7&order=$8;\n}\n\n注意:用url重写时, 正则里如果有”{}”,正则要用双引号包起来\n\n")])])]),a("h3",{attrs:{id:"网页内容的压缩编码与传输速度优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网页内容的压缩编码与传输速度优化","aria-hidden":"true"}},[n._v("#")]),n._v(" 网页内容的压缩编码与传输速度优化")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("我们观察news.163.com的头信息\n请求:\nAccept-Encoding:gzip,deflate,sdch\n响应:\nContent-Encoding:gzip\nContent-Length:36093\n再把页面另存下来,观察,约10W字节,实际传输的36093字节\n原因-------就在于gzip压缩上.\n\n原理: \n浏览器---请求----\x3e 声明可以接受 gzip压缩 或 deflate压缩 或compress 或 sdch压缩\n从http协议的角度看--请求头 声明 acceopt-encoding: gzip deflate sdch  (是指压缩算法,其中sdch是google倡导的一种压缩方式,目前支持的服务器尚不多)\n服务器--\x3e回应---把内容用gzip方式压缩----\x3e发给浏览器\n浏览<-----解码gzip-----接收gzip压缩内容----\n\n推算一下节省的带宽:\n假设 news.163.com  PV  2亿\n2*10^8  *  9*10^4 字节 == \n2*10^8 * 9 * 10^4  * 10^-9 = 12*K*G = 18T\n节省的带宽是非常惊人的\n\ngzip配置的常用参数\ngzip on|off;  #是否开启gzip\ngzip_buffers 32 4K| 16 8K #缓冲(压缩在内存中缓冲几块? 每块多大?)\ngzip_comp_level [1-9] #推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源)\ngzip_disable #正则匹配UA 什么样的Uri不进行gzip\ngzip_min_length 200 # 开始压缩的最小长度(再小就不要压缩了,意义不在)\ngzip_http_version 1.0|1.1 # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)\ngzip_proxied          # 设置请求者代理服务器,该如何缓存内容\ngzip_types text/plain  application/xml # 对哪些类型的文件用压缩 如txt,xml,html ,css\ngzip_vary on|off  # 是否传输gzip压缩标志\n\n\n注意: \n图片/mp3这样的二进制文件,不必压缩\n因为压缩率比较小, 比如100->80字节,而且压缩也是耗费CPU资源的.\n比较小的文件不必压缩,\n")])])]),a("h3",{attrs:{id:"nginx的缓存设置-提高网站性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx的缓存设置-提高网站性能","aria-hidden":"true"}},[n._v("#")]),n._v(" nginx的缓存设置  提高网站性能")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("对于网站的图片,尤其是新闻站, 图片一旦发布, 改动的可能是非常小的.我们希望 能否在用户访问一次后, 图片缓存在用户的浏览器端,且时间比较长的缓存.\n可以, 用到 nginx的expires设置 .\nnginx中设置过期时间,非常简单,\n在location或if段里,来写.\n格式  expires 30s;\n      expires 30m;\n      expires 2h;\n      expires 30d;\n(注意:服务器的日期要准确,如果服务器的日期落后于实际日期,可能导致缓存失效)\n另: 304 也是一种很好的缓存手段\n原理是: 服务器响应文件内容是,同时响应etag标签(内容的签名,内容一变,他也变), 和 last_modified_since 2个标签值\n浏览器下次去请求时,头信息发送这两个标签, 服务器检测文件有没有发生变化,如无,直接头信息返回 etag,last_modified_since\n浏览器知道内容无改变,于是直接调用本地缓存.\n这个过程,也请求了服务器,但是传着的内容极少.\n对于变化周期较短的,如静态html,js,css,比较适于用这个方式\n \nnginx反向代理服务器+负载均衡\n用nginx做反向代理和负载均衡非常简单,\n支持两个用法 1个proxy, 1个upstream,分别用来做反向代理,和负载均衡\n以反向代理为例, nginx不自己处理php的相关请求,而是把php的相关请求转发给apache来处理.\n\n")])])]),a("p",[a("img",{attrs:{src:"https://note.youdao.com/yws/api/personal/file/WEBa4c028483506641fd14ceae318bd5f30?method=download&shareKey=7e9bf161fc9724eff11c62276755db49",alt:"nginx-描述1"}})]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("---这不就是传说的”动静分离”,动静分离不是一个严谨的说法,叫反向代理比较规范.\n\n反向代理后端如果有多台服务器,自然可形成负载均衡,\n但proxy_pass如何指向多台服务器?\n把多台服务器用 upstream指定绑定在一起并起个组名,\n然后proxy_pass指向该组\n\n默认的均衡的算法很简单,就是针对后端服务器的顺序,逐个请求.\n也有其他负载均衡算法,如一致性哈希,需要安装第3方模块.\n\n")])])]),a("h3",{attrs:{id:"nginx具体的压缩配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx具体的压缩配置","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx具体的压缩配置")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("常用以下配置\ngzip on|off\ngzip_buffers 4K|8K 缓冲(和硬盘块相当)\ngzip_comp_level [1-9] 推荐6\ngzip_disable 正则匹配如User-Agent,针对古老浏览器不压缩\ngzip_min_length 200\ngzip_http_version 1.0|1.1\ngzip_types text/plain , application/xml (各mime之间,一定要加空格,不是逗号)\ngzip_vary on|off\n\n")])])]),a("h3",{attrs:{id:"vary的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vary的作用","aria-hidden":"true"}},[n._v("#")]),n._v(" Vary的作用:")]),a("p",[a("img",{attrs:{src:"https://note.youdao.com/yws/api/personal/file/WEB8744484d9ae930366d52001737b6c3ad?method=download&shareKey=81b2490f082f0a38b670ad8a8977bcb9",alt:"Vary的作用"}})]),a("h3",{attrs:{id:"nginx对于图片-js等静态文件的缓存设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx对于图片-js等静态文件的缓存设置","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx对于图片,js等静态文件的缓存设置")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("注:这个缓存是指针对浏览器所做的缓存,不是指服务器端的数据缓存.\n\n主要知识点: location expires指令\n\n        location ~ \\.(jpg|jpeg|png|gif)$ {\n            expires 1d;\n        }\n        location ~ \\.js$ {\n           expires 1h;\n        }\n\n设置并载入新配置文件,用firebug观察,\n会发现 图片内容,没有再次产生新的请求,原因--利用了本地缓存的效果.\n\n\n注: 在大型的新闻站,或文章站中,图片变动的可能性很小,建议做1周左右的缓存\nJs,css等小时级的缓存.\n\n\n如果信息流动比较快,也可以不用expires指令,\n用last_modified, etag功能(主流的web服务器都支持这2个头信息)\n原理是:\n响应: 计算响应内容的签名, etag 和 上次修改时间\n请求: 发送 etatg, If-Modified-Since 头信息.\n服务器收到后,判断etag是否一致, 最后修改时间是否大于if-Modifiled-Since \n如果监测到服务器的内容有变化,则返回304,\n浏览器就知道,内容没变,直接用缓存.\n\n\n304 比起上面的expires 指令\n多了1次请求,\n但是比200状态,少了传输内容.\n\n")])])]),a("h3",{attrs:{id:"nginx反向代理与负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx反向代理与负载均衡","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx反向代理与负载均衡")]),a("p",[n._v("正向代理")]),a("p",[a("img",{attrs:{src:"https://note.youdao.com/yws/api/personal/file/WEBf56a924e638a710b9bd3a4a15623a47e?method=download&shareKey=91ca14d1c16ef6577f58e00fadc49b5d",alt:"Nginx反向代理与负载均衡正向代理"}})]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("具体的负载均衡的方式\n注意:负载均衡是一种方案,实现办法有DNS轮询,\n如下图,DNS服务器允许一个域名有多个A记录,\n那么在用户访问时,一般按地域返回一个较近的解析记录.\n这样,全国不同的地区的用户,看到的163的主页,来自不同的服务器.\n\n\n第二步: 当 解析出结果,比如浏览器连接60.217时,\n这台主机后面还有N台,也要做负载均衡.\n\n1: 硬件上做负载均衡, F5 BIG-IP ,硬件负载均衡(很贵).\n直接从TCP/IP的底层协议上,直接做数据包的中转.\n2: 软件负载均衡, LVS \n3: 反向代理+负载均衡\n\n\n")])])]),a("h3",{attrs:{id:"nginx反向代理设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx反向代理设置","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx反向代理设置")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("例: 把图片重写到 8080端口(既然能写到8080端口,就意味着可以写到其他独立服务器上)\n        location ~ \\.(jpg|jpeg|png|gif)$ {\n                proxy_pass http://192.168.1.204:8080;\n                expires 1d;\n        }\n\n集群与均衡-----如果后端的服务器非常多,该如何写? 又如何均匀的分发任务\n\n")])])]),a("h3",{attrs:{id:"nginx-与memcached的组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx-与memcached的组合","aria-hidden":"true"}},[n._v("#")]),n._v(" nginx 与memcached的组合")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("用法: nginx响应请求时,直接请求memcached,\n如果没有相应的内容,再回调PHP页面,去查询database,并写入memcached.\n\n分析: memcached是k/v存储, key--\x3evalue,\nnginx请求memecached时,用什么做key?\n一般用 uri arg 做key,  如 /abc.php?id=3\n\n")])])]),a("h3",{attrs:{id:"nginx-第三方模块的安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx-第三方模块的安装","aria-hidden":"true"}},[n._v("#")]),n._v(" Nginx 第三方模块的安装")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("以ngx_http_php_memcache_standard_balancer-master为例\n1:解压 到 path/ngx_module\n\n配置:\n./configure --prefix=/xxx/xxx --add_module=/path/ngx_module\n编译 安装\nMake && make instal\n\n配置memcache集群\n\n    upstream memserver {  把用到的memcached节点,声明在一个组里\n        hash_key $request_uri;  // hash计算时的依据,以uri做依据来hash\n        server localhost:11211;\n        server localhost:11212;\n    }\nLocation里\n\n        location / {\n           # root   html;\n           set $memcached_key $uri;\n           memcached_pass memserver;  // memserver为上面的memcache节点的名称\n           error_page 404 /writemem.php;\n           index  index.php index.html index.htm;\n        }\n\n在nginx中做集群与负载均衡,步骤都是一样的\nUpstream {}模块 把多台服务器加入到一个组\n然后 memcached_pass, fastcgi_pass, proxy_pass ==> upstream组\n\n默认的负载均衡的算法:\n是设置计数器,轮流请求N台服务器.\n可以安装第3方模式,来利用uri做hash等等.\n\n如http://wiki.nginx.org/NginxHttpUpstreamConsistentHash \n这个模块就是用一致性hash来请求后端结节,并且其算法,与PHP中的memcache模块的一致性hash算法,兼容.\n\n")])])]),a("h3",{attrs:{id:"安装该模块后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装该模块后","aria-hidden":"true"}},[n._v("#")]),n._v(" 安装该模块后:")]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Nginx.conf中\n\n    upstream memserver {\n        consistent_hash $request_uri;\n        server localhost:11211;\n        server localhost:11212;\n    }\n\n")])])])])}],!1,null,null,null);e.default=r.exports}}]);